<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yinyuejun.top/</id>
    <title>你的饮月君</title>
    <updated>2023-07-27T03:44:16.970Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <author>
        <name>你的饮月君</name>
        <email>1686588552@qq.com</email>
        <uri>https://yinyuejun.top</uri>
    </author>
    <link rel="alternate" href="https://yinyuejun.top/"/>
    <link rel="self" href="https://yinyuejun.top/feed.atom"/>
    <subtitle>你的饮月君' Blog</subtitle>
    <logo>https://yinyuejun.top/horse.svg</logo>
    <icon>https://yinyuejun.top/horse.svg</icon>
    <rights>MIT License</rights>
    <entry>
        <title type="html"><![CDATA[Electron 快速入门]]></title>
        <id>https://yinyuejun.top/posts/electron.html</id>
        <link href="https://yinyuejun.top/posts/electron.html"/>
        <updated>2023-07-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Electron 快速入门]]></summary>
        <content type="html"><![CDATA[<h1>快速入门</h1>
<p>本指南将会通过使用Electron创建一个极简的 Hello World 应用一步步的带你了解，该应用与<a href="https://github.com/electron/electron-quick-start"><code>electron/electron-quick-start</code></a>类似。</p>
<p>通过这个教程，你的app将会打开一个浏览器窗口，来展示包含当前正在运行的 Chromium, Node.js与 Electronweb等版本信息的web界面</p>
<h2>Prerequisites</h2>
<p>在使用Electron进行开发之前，您需要安装 <a href="https://nodejs.org/en/download/">Node.js</a>。 我们建议您使用最新的LTS版本。</p>
<blockquote>
<p>请使用为你平台预构建的 Node.js 安装器来进行安装， 否则，您可能会遇到与不同开发工具不兼容的问题。</p>
</blockquote>
<p>要检查 Node.js 是否正确安装，请在您的终端输入以下命令：</p>
<pre><code class="language-sh">node -v
npm -v
</code></pre>
<p>这两个命令应输出了 Node.js 和 npm 的版本信息。</p>
<p><strong>注意</strong> 因为 Electron 将 Node.js 嵌入到其二进制文件中，你应用运行时的 Node.js 版本与你系统中运行的 Node.js 版本无关。</p>
<h2>创建你的应用程序</h2>
<h3>使用脚手架创建</h3>
<p>Electron 应用程序遵循与其他 Node.js 项目相同的结构。 首先创建一个文件夹并初始化 npm 包。</p>
<pre><code class="language-sh">mkdir my-electron-app &amp;&amp; cd my-electron-app
npm init
</code></pre>
<p><code>init</code>初始化命令会提示您在项目初始化配置中设置一些值 为本教程的目的，有几条规则需要遵循：</p>
<ul>
<li><code>entry point</code> 应为 <code>main.js</code>.</li>
<li><code>author</code> 与 <code>description</code> 可为任意值，但对于<a href="#package-and-distribute-your-application">应用打包</a>是必填项。</li>
</ul>
<p>你的 <code>package.json</code> 文件应该像这样：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;my-electron-app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Hello World!&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;author&quot;: &quot;Jane Doe&quot;,
  &quot;license&quot;: &quot;MIT&quot;
}
</code></pre>
<p>然后，将 <code>electron</code> 包安装到应用的开发依赖中。</p>
<pre><code class="language-sh">$ npm install --save-dev electron
</code></pre>
<blockquote>
<p>注意：如果您在安装 Electron 时遇到任何问题，请 参见 [高级安装][advanced-installation] 指南。</p>
</blockquote>
<p>最后，您希望能够执行 Electron 如下所示，在您的 <a href="https://docs.npmjs.com/cli/v7/using-npm/scripts"><code>package.json</code></a>配置文件中的<code>scripts</code>字段下增加一条<code>start</code>命令：</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;electron .&quot;
  }
}
</code></pre>
<p><code>start</code>命令能让您在开发模式下打开您的应用</p>
<pre><code class="language-sh">npm start
</code></pre>
<blockquote>
<p>注意：此脚本将告诉 Electron 在您项目根目录运行 此时，您的应用将立即抛出一个错误提示您它无法找到要运行的应用</p>
</blockquote>
<h3>运行主进程</h3>
<p>任何 Electron 应用程序的入口都是 <code>main</code> 文件。 这个文件控制了<strong>主进程</strong>，它运行在一个完整的Node.js环境中，负责控制您应用的生命周期，显示原生界面，执行特殊操作并管理渲染器进程(稍后详细介绍)。</p>
<p>执行期间，Electron 将依据应用中 <code>package.json</code>配置下<a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json#main"><code>main</code></a>字段中配置的值查找此文件，您应该已在<a href="#scaffold-the-project">应用脚手架</a>步骤中配置。</p>
<p>要初始化这个<code>main</code>文件，需要在您项目的根目录下创建一个名为<code>main.js</code>的空文件。</p>
<blockquote>
<p>注意：如果您此时再次运行<code>start</code>命令，您的应用将不再抛出任何错误！ 然而，它不会做任何事因为我们还没有在<code>main.js</code>中添加任何代码。</p>
</blockquote>
<h3>创建页面</h3>
<p>在可以为我们的应用创建窗口前，我们需要先创建加载进该窗口的内容。 在 Electron 中，每个窗口中无论是本地的HTML文件还是远程URL都可以被加载显示。</p>
<p>此教程中，您将采用本地HTML的方式。 在您的项目根目录下创建一个名为<code>index.html</code>的文件：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; script-src 'self'&quot;&gt;
    &lt;meta http-equiv=&quot;X-Content-Security-Policy&quot; content=&quot;default-src 'self'; script-src 'self'&quot;&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
    We are using Node.js &lt;span id=&quot;node-version&quot;&gt;&lt;/span&gt;,
    Chromium &lt;span id=&quot;chrome-version&quot;&gt;&lt;/span&gt;,
    and Electron &lt;span id=&quot;electron-version&quot;&gt;&lt;/span&gt;.
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>注意：在这个HTML文本中，您会发现主体文本中丢失了版本编号。 稍后我们将使用 JavaScript 动态插入它们。</p>
</blockquote>
<h3>在窗口中打开您的页面</h3>
<p>现在您有了一个页面，将它加载进应用窗口中。 要做到这一点，你需要 两个Electron模块：</p>
<ul>
<li>[<code>app</code>][app] 模块，它控制应用程序的事件生命周期。</li>
<li>[<code>BrowserWindow</code>][browser-window] 模块，它创建和管理应用程序 窗口。</li>
</ul>
<p>因为主进程运行着Node.js，您可以在文件头部将他们导入作为<a href="https://nodejs.org/docs/latest/api/modules.html#modules_modules_commonjs_modules">公共JS</a>模块：</p>
<pre><code class="language-js">const { app, BrowserWindow } = require('electron')
</code></pre>
<p>然后，添加一个<code>createWindow()</code>方法来将<code>index.html</code>加载进一个新的<code>BrowserWindow</code>实例。</p>
<pre><code class="language-js">function createWindow () {
  const win = new BrowserWindow({
    width: 800,
    height: 600
  })

  win.loadFile('index.html')
}
</code></pre>
<p>接着，调用<code>createWindow()</code>函数来打开您的窗口。</p>
<p>在 Electron 中，只有在 <code>app</code> 模块的 [<code>ready</code>][app-ready] 事件被激发后才能创建浏览器窗口。 您可以通过使用 [<code>app.whenReady()</code>][app-when-ready] API来监听此事件。 在<code>whenReady()</code>成功后调用<code>createWindow()</code>。</p>
<pre><code class="language-js">app.whenReady().then(() =&gt; {
  createWindow()
})
</code></pre>
<blockquote>
<p>注意：此时，您的电子应用程序应当成功 打开显示您页面的窗口！</p>
</blockquote>
<h3>管理窗口的生命周期</h3>
<p>虽然你现在可以打开一个浏览器窗口，但你还需要一些额外的模板代码使其看起来更像是各平台原生的。 应用程序窗口在每个OS下有不同的行为，Electron将在app中实现这些约定的责任交给开发者们。</p>
<p>一般而言，你可以使用 <code>进程</code> 全局的 <a href="https://nodejs.org/api/process.html#process_process_platform"><code>platform</code></a> 属性来专门为某些操作系统运行代码。</p>
<h4>关闭所有窗口时退出应用 (Windows &amp; Linux)</h4>
<p>在Windows和Linux上，关闭所有窗口通常会完全退出一个应用程序。</p>
<p>To implement this, listen for the <code>app</code> module's [<code>'window-all-closed'</code>][window-all-closed] event, and call [<code>app.quit()</code>][app-quit] if the user is not on macOS (<code>darwin</code>).</p>
<pre><code class="language-js">app.on('window-all-closed', function () {
  if (process.platform !== 'darwin') app.quit()
})
</code></pre>
<h4>如果没有窗口打开则打开一个窗口 (macOS)</h4>
<p>当 Linux 和 Windows 应用在没有窗口打开时退出了，macOS 应用通常即使在没有打开任何窗口的情况下也继续运行，并且在没有窗口可用的情况下激活应用时会打开新的窗口。</p>
<p>To implement this feature, listen for the <code>app</code> module's [<code>activate</code>][activate] event, and call your existing <code>createWindow()</code> method if no browser windows are open.</p>
<p>因为窗口无法在 <code>ready</code> 事件前创建，你应当在你的应用初始化后仅监听 <code>activate</code> 事件。 通过在您现有的 <code>whenReady()</code> 回调中附上您的事件监听器来完成这个操作。</p>
<pre><code class="language-js">app.whenReady().then(() =&gt; {
  createWindow()

  app.on('activate', function () {
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})
</code></pre>
<blockquote>
<p>注意：此时，您的窗口控件应功能齐全！</p>
</blockquote>
<h3>通过预加载脚本从渲染器访问Node.js。</h3>
<p>现在，最后要做的是输出Electron的版本号和它的依赖项到你的web页面上。</p>
<p>在主进程通过Node的全局 <code>process</code> 对象访问这个信息是微不足道的。 然而，你不能直接在主进程中编辑DOM，因为它无法访问渲染器 <code>文档</code> 上下文。 它们存在于完全不同的进程！</p>
<blockquote>
<p>Note: If you need a more in-depth look at Electron processes, see the [Process Model][] document.</p>
</blockquote>
<p>这是将 <strong>预加载</strong> 脚本连接到渲染器时派上用场的地方。 预加载脚本在渲染器进程加载之前加载，并有权访问两个 渲染器全局 (例如 <code>window</code> 和 <code>document</code>) 和 Node.js 环境。</p>
<p>创建一个名为 <code>preload.js</code> 的新脚本如下：</p>
<pre><code class="language-js">window.addEventListener('DOMContentLoaded', () =&gt; {
  const replaceText = (selector, text) =&gt; {
    const element = document.getElementById(selector)
    if (element) element.innerText = text
  }

  for (const dependency of ['chrome', 'node', 'electron']) {
    replaceText(`${dependency}-version`, process.versions[dependency])
  }
})
</code></pre>
<p>上面的代码访问 Node.js <code>process.versions</code> 对象，并运行一个基本的 <code>replaceText</code> 辅助函数将版本号插入到 HTML 文档中。</p>
<p>要将此脚本附加到渲染器流程，请在你现有的 <code>BrowserWindow</code> 构造器中将路径中的预加载脚本传入 <code>webPreferences.preload</code> 选项。</p>
<pre><code class="language-js">// 在文件头部引入 Node.js 中的 path 模块
const path = require('path')

// 修改现有的 createWindow() 函数
function createWindow () {
  const win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js')
    }
  })

  win.loadFile('index.html')
}
// ...
</code></pre>
<p>这里使用了两个Node.js概念：</p>
<ul>
<li>The <a href="https://nodejs.org/api/modules.html#modules_dirname"><code>__dirname</code></a> string points to the path of the currently executing script (in this case, your project's root folder).</li>
<li>The <a href="https://nodejs.org/api/path.html#path_path_join_paths"><code>path.join</code></a> API joins multiple path segments together, creating a combined path string that works across all platforms.</li>
</ul>
<p>我们使用一个相对当前正在执行JavaScript文件的路径，这样您的相对路径将在开发模式和打包模式中都将有效。</p>
<h3>额外：将功能添加到您的网页内容</h3>
<p>此刻，您可能想知道如何为您的应用程序添加更多功能。</p>
<p>对于与您的网页内容的任何交互，您想要将脚本添加到您的渲染器进程中。 由于渲染器运行在正常的 Web 环境中，因此您可以在 <code>index.html</code> 文件关闭 <code>&lt;/body&gt;</code> 标签之前添加一个 <code>&lt;script&gt;</code> 标签，来包括您想要的任意脚本：</p>
<pre><code class="language-html">&lt;script src=&quot;./renderer.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>The code contained in <code>renderer.js</code> can then use the same JavaScript APIs and tooling you use for typical front-end development, such as using <a href="https://webpack.js.org"><code>webpack</code></a> to bundle and minify your code or <a href="https://reactjs.org">React</a> to manage your user interfaces.</p>
<h3>回顾</h3>
<p>完成上述步骤后，您应该有一个功能齐全的Electron程序，如下所示：</p>
<p><img src="https://yinyuejun.top/public/simplest-electron-app.png" alt="最简的 Electron 应用程序"></p>
<!--TODO(erickzhao): Remove the individual code blocks for static website -->
<p>完整代码如下：</p>
<pre><code class="language-js">// main.js

// Modules to control application life and create native browser window
const { app, BrowserWindow } = require('electron')
const path = require('path')

function createWindow () {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js')
    }
  })

  // and load the index.html of the app.
  mainWindow.loadFile('index.html')

  // Open the DevTools.
  // mainWindow.webContents.openDevTools()
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// 部分 API 在 ready 事件触发后才能使用。
app.whenReady().then(() =&gt; {
  createWindow()

  app.on('activate', function () {
    // On macOS it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) createWindow()
  })
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', function () {
  if (process.platform !== 'darwin') app.quit()
})

// In this file you can include the rest of your app's specific main process
// code. 也可以拆分成几个文件，然后用 require 导入。
</code></pre>
<pre><code class="language-js">// preload.js

// All of the Node.js APIs are available in the preload process.
// 它拥有与Chrome扩展一样的沙盒。
window.addEventListener('DOMContentLoaded', () =&gt; {
  const replaceText = (selector, text) =&gt; {
    const element = document.getElementById(selector)
    if (element) element.innerText = text
  }

  for (const dependency of ['chrome', 'node', 'electron']) {
    replaceText(`${dependency}-version`, process.versions[dependency])
  }
})
</code></pre>
<pre><code class="language-html">&lt;!--index.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; script-src 'self'&quot;&gt;
    &lt;meta http-equiv=&quot;X-Content-Security-Policy&quot; content=&quot;default-src 'self'; script-src 'self'&quot;&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World!&lt;/h1&gt;
    We are using Node.js &lt;span id=&quot;node-version&quot;&gt;&lt;/span&gt;,
    Chromium &lt;span id=&quot;chrome-version&quot;&gt;&lt;/span&gt;,
    and Electron &lt;span id=&quot;electron-version&quot;&gt;&lt;/span&gt;.

    &lt;!-- You can also require other files to run in this process --&gt;
    &lt;script src=&quot;./renderer.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-fiddle"></code></pre>
<p>总结我们所做的所有步骤：</p>
<p>*我们启动了一个Node.js程序，并将Electron添加为依赖。</p>
<ul>
<li>
<p>We created a <code>main.js</code> script that runs our main process, which controls our app<br>
and runs in a Node.js environment. 在此脚本中， 我们使用 Electron 的 <code>app</code> 和  <code>BrowserWindow</code> 模块来创建一个浏览器窗口，在一个单独的进程(渲染器)中显示网页内容。</p>
</li>
<li>
<p>为了访问渲染器中的Node.js的某些功能，我们在 <code>BrowserWindow</code> 的构造函数上附加了一个预加载脚本。</p>
</li>
</ul>
<h2>打包并分发您的应用程序</h2>
<p>最快捷的打包方式是使用 <a href="https://www.electronforge.io">Electron Forge</a>。</p>
<ol>
<li>
<p>将 Electron Forge 添加到您应用的开发依赖中，并使用其&quot;import&quot;命令设置 Forge 的脚手架：</p>
<pre><code class="language-sh">npm install --save-dev @electron-forge/cli
npx electron-forge import

✔ Checking your system
✔ Initializing Git Repository
✔ Writing modified package.json file
✔ Installing dependencies
✔ Writing modified package.json file
✔ Fixing .gitignore

We have ATTEMPTED to convert your app to be in a format that electron-forge understands.

Thanks for using &quot;electron-forge&quot;!!!
</code></pre>
</li>
<li>
<p>使用 Forge 的 <code>make</code> 命令来创建可分发的应用程序：</p>
<pre><code class="language-sh">npm run make

&gt; my-electron-app@1.0.0 make /my-electron-app
&gt; electron-forge make

✔ Checking your system
✔ Resolving Forge Config
We need to package your application before we can make it
✔ Preparing to Package Application for arch: x64
✔ Preparing native dependencies
✔ Packaging Application
Making for the following targets: zip
✔ Making for target: zip - On platform: darwin - For arch: x64
</code></pre>
<p>Electron Forge creates the <code>out</code> folder where your package will be located:</p>
<pre><code class="language-plain">// Example for macOS
out/
├── out/make/zip/darwin/x64/my-electron-app-darwin-x64-1.0.0.zip
├── ...
└── out/my-electron-app-darwin-x64/my-electron-app.app/Contents/MacOS/my-electron-app
</code></pre>
</li>
</ol>
<!-- [advanced-installation]: ./installation.md -->
<!-- [app]: ../api/app.md
[browser-window]: ../api/browser-window.md -->
<!-- [app-ready]: ../api/app.md#event-ready
[app-when-ready]: ../api/app.md#appwhenready -->
<!-- [window-all-closed]: ../api/app.md#event-window-all-closed
[app-quit]: ../api/app.md#appquit

[activate]: ../api/app.md#event-activate-macos

[Process Model]: ./process-model.md -->
]]></content>
        <author>
            <name>你的饮月君</name>
            <email>1686588552@qq.com</email>
            <uri>https://yinyuejun.top</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[下班倒计时]]></title>
        <id>https://yinyuejun.top/posts/下班倒计时.html</id>
        <link href="https://yinyuejun.top/posts/下班倒计时.html"/>
        <updated>2023-07-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[下班倒计时]]></summary>
        <content type="html"><![CDATA[<h1>下班倒计时</h1>
<pre><code class="language-javascript">// ==UserScript==
// @name         下班倒计时
// @namespace    https://bbs.tampermonkey.net.cn/
// @version      0.1.1
// @description  一个提醒你准时下班的demo,请使用ScriptCat运行
// @author       yinyuejun
// @crontab      59 17 * * 1,2,3,4,5
// @grant        GM_notification
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_updateNotification
// @debug
// ==/UserScript==
function getAvatarAndImage(id) {
  const baseUrl = &quot;https://gitee.com/hewang1an/StarRail-plugin/raw/main/resources/panel/resources&quot;;
  return {
    avatarUrl: baseUrl + `/avatar/${id}.png`,
    charImageUrl: baseUrl + `/char_image/${id}.png`,
  };
}

async function fetchCharacterData() {
  try {
    const response = await fetch(&quot;https://songzhanpeng.github.io/character.json&quot;);
    const data = await response.json();
    return data;
  } catch (error) {
    console.error(&quot;Error fetching character data:&quot;, error);
    return null;
  }
}

async function getRandomRole() {
  const cachedData = GM_getValue(&quot;characterData&quot;);
  if (cachedData) {
    const roleList = Object.entries(cachedData);
    const randomIndex = Math.floor(Math.random() * roleList.length);
    const roleInfo = roleList[randomIndex];
    const { avatarUrl, charImageUrl } = getAvatarAndImage(roleInfo[0]);
    return {
      id: roleInfo[1].id,
      name: roleInfo[1].name,
      avatar: avatarUrl,
      charImage: charImageUrl,
    };
  } else {
    const characterData = await fetchCharacterData();
    if (characterData) {
      GM_setValue(&quot;characterData&quot;, characterData);
      return getRandomRole();
    }
    return null;
  }
}

(async () =&gt; {

    const role = await getRandomRole();
    let i;
    GM_notification({
        title: `${role.name}:下班60s倒计时`,
        text: '准时下班，美好生活',
        image: role.avatar,
        ondone: (user) =&gt; {
            console.log('done user:', user);
            clearInterval(i);
            resolve();
        },
        onclick: () =&gt; {
            console.log('click');
        },
        oncreate: (id) =&gt; {
            let t = 1;
            i = setInterval(() =&gt; {
                GM_updateNotification(id, {
                    title: '下班' + (60 - t) + 's倒计时',
                    progress: 100 / 60 * t
                });
                if (t == 60) {
                    clearInterval(i);
                    GM_updateNotification(id, {
                        title: '下班啦！',
                        progress: 100
                    });
                    resolve();
                }
                t++;
            }, 1000);
        },
        // 开启进度条模式
        progress: 0,
    });
})();



</code></pre>
]]></content>
        <author>
            <name>你的饮月君</name>
            <email>1686588552@qq.com</email>
            <uri>https://yinyuejun.top</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[定时提醒小助手]]></title>
        <id>https://yinyuejun.top/posts/定时提醒喝水小助手.html</id>
        <link href="https://yinyuejun.top/posts/定时提醒喝水小助手.html"/>
        <updated>2023-07-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[定时提醒小助手]]></summary>
        <content type="html"><![CDATA[<h1>定时提醒小助手</h1>
<pre><code class="language-javascript">// ==UserScript==
// @name         提醒喝水小助手
// @namespace    https://bbs.tampermonkey.net.cn/
// @version      0.1.0
// @description  工作日每半个小时提醒你喝水，定时时间可以自行修改
// @author       yinyuejun
// @crontab      */30 10-20/1 * * 1-5
// @grant        GM_notification
// @grant        GM_getValue
// @grant        GM_setValue
// @console log
// ==/UserScript==

function getAvatarAndImage(id) {
  const baseUrl = &quot;https://gitee.com/hewang1an/StarRail-plugin/raw/main/resources/panel/resources&quot;;
  return {
    avatarUrl: baseUrl + `/avatar/${id}.png`,
    charImageUrl: baseUrl + `/char_image/${id}.png`,
  };
}

async function fetchCharacterData() {
  try {
    const response = await fetch(&quot;https://songzhanpeng.github.io/character.json&quot;);
    const data = await response.json();
    return data;
  } catch (error) {
    console.error(&quot;Error fetching character data:&quot;, error);
    return null;
  }
}

async function getRandomRole() {
  const cachedData = GM_getValue(&quot;characterData&quot;);
  if (cachedData) {
    const roleList = Object.entries(cachedData);
    const randomIndex = Math.floor(Math.random() * roleList.length);
    const roleInfo = roleList[randomIndex];
    const { avatarUrl, charImageUrl } = getAvatarAndImage(roleInfo[0]);
    return {
      id: roleInfo[1].id,
      name: roleInfo[1].name,
      avatar: avatarUrl,
      charImage: charImageUrl,
    };
  } else {
    const characterData = await fetchCharacterData();
    if (characterData) {
      GM_setValue(&quot;characterData&quot;, characterData);
      return getRandomRole();
    }
    return null;
  }
}

(async () =&gt; {
  const currentDate = new Date();
  const currentHour = currentDate.getHours();

  if (currentHour &gt;= 9 &amp;&amp; currentHour &lt;= 20) {
    const role = await getRandomRole();
    if (role) {
      GM_notification({
        title: `${role.name}的温馨提醒`,
        text: &quot;开拓者，是时候喝杯水休息一下了&quot;,
        image: role.avatar,
      });
    }
  }
})();
</code></pre>
]]></content>
        <author>
            <name>你的饮月君</name>
            <email>1686588552@qq.com</email>
            <uri>https://yinyuejun.top</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[提醒走动小助手]]></title>
        <id>https://yinyuejun.top/posts/提醒走动小助手.html</id>
        <link href="https://yinyuejun.top/posts/提醒走动小助手.html"/>
        <updated>2023-07-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[提醒走动小助手]]></summary>
        <content type="html"><![CDATA[<h1>提醒走动小助手</h1>
<pre><code class="language-javascript">// ==UserScript==
// @name         提醒走动小助手
// @namespace    https://bbs.tampermonkey.net.cn/
// @version      0.1.0
// @description  每隔一个小时提醒你走动一下，定时时间可以自行修改
// @author       yinyuejun
// @crontab      0 10-20/1 * * 1-5
// @grant        GM_notification
// @grant        GM_getValue
// @grant        GM_setValue
// @console log
// ==/UserScript==

function getAvatarAndImage(id) {
  const baseUrl = &quot;https://gitee.com/hewang1an/StarRail-plugin/raw/main/resources/panel/resources&quot;;
  return {
    avatarUrl: baseUrl + `/avatar/${id}.png`,
    charImageUrl: baseUrl + `/char_image/${id}.png`,
  };
}

async function fetchCharacterData() {
  try {
    const response = await fetch(&quot;https://songzhanpeng.github.io/character.json&quot;);
    const data = await response.json();
    return data;
  } catch (error) {
    console.error(&quot;Error fetching character data:&quot;, error);
    return null;
  }
}

async function getRandomRole() {
  const cachedData = GM_getValue(&quot;characterData&quot;);
  if (cachedData) {
    const roleList = Object.entries(cachedData);
    const randomIndex = Math.floor(Math.random() * roleList.length);
    const roleInfo = roleList[randomIndex];
    const { avatarUrl, charImageUrl } = getAvatarAndImage(roleInfo[0]);
    return {
      id: roleInfo[1].id,
      name: roleInfo[1].name,
      avatar: avatarUrl,
      charImage: charImageUrl,
    };
  } else {
    const characterData = await fetchCharacterData();
    if (characterData) {
      GM_setValue(&quot;characterData&quot;, characterData);
      return getRandomRole();
    }
    return null;
  }
}

(async () =&gt; {
  const currentDate = new Date();
  const currentHour = currentDate.getHours();

  if (currentHour &gt;= 9 &amp;&amp; currentHour &lt;= 20) {
    const role = await getRandomRole();
    console.log(role)
    GM_notification({
      title: role.name,
      text: &quot;你已经坐了一小时了，走动一下吧！&quot;,
      image: role.avatar,
    });
  }
})();

</code></pre>
]]></content>
        <author>
            <name>你的饮月君</name>
            <email>1686588552@qq.com</email>
            <uri>https://yinyuejun.top</uri>
        </author>
    </entry>
</feed>