{
    "version": "https://jsonfeed.org/version/1",
    "title": "Clark Cui",
    "home_page_url": "https://clark-cui.top/",
    "feed_url": "https://clark-cui.top/feed.json",
    "description": "Clark Cui' Blog",
    "icon": "https://clark-cui.top/horse.svg",
    "author": {
        "name": "Clark Cui",
        "url": "https://clark-cui.top"
    },
    "items": [
        {
            "content_html": "<h3>优化的原因</h3>\n<p>react 里的一个基本常识是 re-render：当一个组件里的某个状态改变的时候，他会重新渲染，也就是重新执行所有组件代码，包括它的子组件。</p>\n<p>所以会带来很多不必要的重新渲染。</p>\n<h3>useMemo</h3>\n<p>useMemo 的基本理念是，它允许我们在渲染之间 &quot;记住 &quot;一个计算值</p>\n<h4>使用的场景举例</h4>\n<pre><code class=\"language-tsx\">function App() {\n  const [selectedNum, setSelectedNum] = React.useState(100);\n  const time = useTime();\n\n  const allPrimes = React.useMemo(() =&gt; {\n    const result = [];\n\n    for (let counter = 2; counter &lt; selectedNum; counter++) {\n      if (isPrime(counter)) {\n        result.push(counter);\n      }\n    }\n\n    return result;\n  }, [selectedNum]);\n\n   return (\n    &lt;-省略dom-&gt;\n   )\n</code></pre>\n<p>这里 App 组件里有一个状态 selectedNum,还有一个自定义 hook 导出的状态 time。假如不使用 useMemo 包裹 allPrimes，那么每当 time 变化的时候，就会重新执行 allPrimses 里面的代码，造成浪费；然而我们的 allPrimes 其实只跟 selectedNum 相关，所以我们这里用 useMemo 缓存函数包裹后，里面的代码就只会在 selectedNum 变化时执行，而不受 App 组件的 re-render 影响。</p>\n<p>当然，这里也可以有其他的写法，我们可以把 allPrimes 和 selectedNum 包括它的 dom 合并成一个子组件，time 和它的 dom 也合并成一个子组件</p>\n<pre><code class=\"language-tsx\">function App(){\n\n  return(\n  \t&lt;Time /&gt;\n    &lt;AllPrimes /&gt;\n  )\n}\n</code></pre>\n<p>这样，他们的状态隔离开，也可以实现当 time 里面的状态改变的时候，不会影响别的代码去 re-render。</p>\n<p>但是，有时候，我们反而是需要把状态放到外部组件的，因为可能有别的组件也同样依赖这个状态。</p>\n<pre><code class=\"language-tsx\">function App(){\n  const time = useTime();\n  return(\n  \t&lt;Time time={time} /&gt;\n    &lt;AllPrimes /&gt;\n  )\n}\n</code></pre>\n<p>这样的话，当 App 组件的 time 状态变化的时候，其实同样会使 Time 组件和 AllPrimes 组件 re-render。这个时候，就可以使用 React.memo 来优化</p>\n<pre><code class=\"language-tsx\">const PureAllPrimes = React.memo(AllPrimes);\nfunction App(){\n  const time = useTime();\n  return(\n  \t&lt;Time time={time} /&gt;\n    &lt;PureAllPrimes /&gt;\n  )\n}\n</code></pre>\n<p>React.memo 可以把一个组件变成 pure component，pure component 只有在 props 变化的时候，才会 re-render；</p>\n<p>当然，也可以在 AllPrimes 组件里，导出的时候去使用 React.memo</p>\n<pre><code class=\"language-tsx\">export default React.memo(AllPrimes);\n</code></pre>\n<p>我们来举另外一个例子</p>\n<p>Boxes 是一个 pure component,只有 boxes 变化的时候，才会 re-render;</p>\n<pre><code class=\"language-tsx\">function Boxes({ boxes }) {\n  return (\n    &lt;div className=&quot;boxes-wrapper&quot;&gt;\n      {boxes.map((boxStyles, index) =&gt; (\n        &lt;div key={index} className=&quot;box&quot; style={boxStyles} /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n\nexport default React.memo(Boxes);\n</code></pre>\n<p>App 组件里引用了 Boxes,并声明常量 boxes 传入 Boxes 组件里</p>\n<pre><code class=\"language-tsx\">import Boxes from './Boxes';\n\nfunction App() {\n  const [name, setName] = React.useState('');\n  const [boxWidth, setBoxWidth] = React.useState(1);\n  const boxes = [\n    { flex: boxWidth, background: 'hsl(345deg 100% 50%)' },\n    { flex: 3, background: 'hsl(260deg 100% 40%)' },\n    { flex: 1, background: 'hsl(50deg 100% 60%)' },\n  ];\n\n  return (\n    &lt;&gt;\n      &lt;Boxes boxes={boxes} /&gt;\n      &lt;-省略dom-&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>当状态 name 变化的时候，我们期望只是 re-render App 组件，Boxes 组件不 re-render，然而 Boxes 组件仍然 re-render 了。这是因为，App 组件 re-render 的时候，重新生成了 boxes 变量，尽管是同样的值，但不是一个引用，所以导致了 Boxes 组件的 re-render</p>\n<p>要解决这个问题，只需要使用 useMemo 包裹一下即可</p>\n<pre><code class=\"language-tsx\">const boxes = React.useMemo(() =&gt; {\n  return [\n    { flex: boxWidth, background: &quot;hsl(345deg 100% 50%)&quot; },\n    { flex: 3, background: &quot;hsl(260deg 100% 40%)&quot; },\n    { flex: 1, background: &quot;hsl(50deg 100% 60%)&quot; },\n  ];\n}, [boxWidth]);\n</code></pre>\n<h3>UseCallback</h3>\n<p>它跟 useMemo 是一样的，都是缓存函数，但是他缓存的不是值，而是函数；</p>\n<h4>使用场景举例</h4>\n<p>MegaBoost 是一个 pure component,接受一个 callback 回调函数，只有当 callback 变化的时候才会 re-render</p>\n<pre><code class=\"language-tsx\">function MegaBoost({ handleClick }) {\n  console.log(&quot;Render MegaBoost&quot;);\n\n  return (\n    &lt;button className=&quot;mega-boost-button&quot; onClick={handleClick}&gt;\n      MEGA BOOST!\n    &lt;/button&gt;\n  );\n}\n\nexport default React.memo(MegaBoost);\n</code></pre>\n<p>App 组件里引用了 MegaBoost</p>\n<pre><code class=\"language-tsx\">function App() {\n  const [count, setCount] = React.useState(0);\n  function handleMegaBoost() {\n    setCount((currentValue) =&gt; currentValue + 1234);\n  }\n\n  return (\n    &lt;&gt;\n      Count: {count}\n      &lt;button\n        onClick={() =&gt; {\n          setCount(count + 1);\n        }}\n      &gt;\n        Click me!\n      &lt;/button&gt;\n      &lt;MegaBoost handleClick={handleMegaBoost} /&gt;\n    &lt;/&gt;\n  );\n}\n\nexport default App;\n</code></pre>\n<p>App 里声明了一个状态 count，一个函数 handleMegaBoost 并传入 MegaBoost 组件。</p>\n<p>当状态 count 变化的时候，会触发 App 组件的 re-render，并且重新生成一个新的 handleMegaBoost 传入 MegaBoost 组件，导致 MegaBoost 组件的 re-render。</p>\n<p>怎么解决这个问题呢？很简单，使用缓存函数即可</p>\n<pre><code class=\"language-tsx\">const handleMegaBoost = React.useMemo(() =&gt; {\n  return function () {\n    setCount((currentValue) =&gt; currentValue + 1234);\n  };\n}, []);\n</code></pre>\n<p>但是，一般我们更倾向于使用 useCallback</p>\n<pre><code class=\"language-tsx\">const handleMegaBoost = React.useCallback(() =&gt; {\n  setCount((currentValue) =&gt; currentValue + 1234);\n}, []);\n</code></pre>\n<h3>总结</h3>\n<ol>\n<li>组件里一些”经过复杂的逻辑计算而得到某个值“需要使用 Usememo 包裹，保证组件在 re-render 的时候不去重复计算</li>\n<li>父子组件的场景，子组件尽量用 React.memo 包裹成 pure component，避免父组件的 re-render 导致子组件跟着一起 re-render</li>\n<li>父子组件的场景，父组件声明变量传入子组件的时候，尽量用 useMemo 包裹，避免父组件 re-render 导致重新生成变量，而进一步导致子组件的 re-render</li>\n<li>父子组件的场景，副组件声明 callback 传入子组件的时候，尽量使用 useCallback 包裹，避免父组件 re-render 导致重新生成 callback，而进一步导致子组件的 re-render</li>\n</ol>\n<h3>引用链接</h3>\n<p><a href=\"https://www.joshwcomeau.com/react/usememo-and-usecallback/#use-case-2-preserved-references\">引用链接</a></p>\n",
            "url": "https://clark-cui.top/posts/scratch-gui.html",
            "title": "Scratch Gui",
            "summary": "Scratch Gui",
            "date_modified": "2023-06-21T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>Why write the annual summary at this time?</h3>\n<p>The company's fiscal year is based on March of each year. At present, most of my energy is devoted to work, so the company's year is just like my year.</p>\n<h3>About work.</h3>\n<p>In January 2022, our entire department received a layoff letter and I had to leave an online education company. After two months of job hunting, I received offers from several companies, including some big traditional web2 companies, and of course my current company, okx.</p>\n<p>After failing at an online education company, I learned how to choose a good company, it's simple, it has to make money or have strong profit expectations.</p>\n<p>So, without much hesitation, I went to okx and refused other offers, even though the salary at okx was not the best.</p>\n<p>After working at okx for a year, I have grown from a dapp beginner to an expert.</p>\n<p>At the end of this year, I received S in the Performance Evaluation, which made me excited all night.</p>\n<h3>About Interest Development</h3>\n<p>There is always a special feeling when developing your own projects, and I call this feeling interest development.</p>\n<p>This year, I spend most of my spare time on my blog themes, which help me receive more than 100 stars. It's really interesting.</p>\n<p>I also submitted PR to some open source projects, mostly to fix bugs. I didn't intend to submit PR to any project, I don't like the feeling of intentional work.</p>\n<p>I found that if you want to go deep into an open source project, you have to join the dev team and communicate with them in-depth, otherwise, the code will be submitted haphazardly while wasting your time, but also consuming the maintenance team's experience to review.</p>\n<p>Apparently, I don't have much time to participate in the open source community communication at the moment, so everything I do at the moment is a matter of interest, most of them are bug fixes that do not affect the main architecture.</p>\n<p>Maybe someday, when I'm not so busy with work, I can spend more time on open source projects.</p>\n<h3>About Life</h3>\n<p>This year I went to Shanghai, Suzhou, Hangzhou, Jiangsu, Tianjin, and Hebei with my girlfriend. I am happy.</p>\n<h3>About money management</h3>\n<p>My main financial tools this year are bank deposits, money funds, and Bitcoin spots. My investment approach is conservative, but I still get more than 20% returns. Most of them come from Bitcoin. Of course, I've liquidated my position now, maybe I'll buy when Bitcoin goes down again.</p>\n<p>Next year I plan to buy some stocks and ETH spots. Although they will not account for much, because high returns will also assume high risk, my goal is 8% APY, that's enough for me.</p>\n",
            "url": "https://clark-cui.top/posts/2022 Annual Summary.html",
            "title": "2022 Annual Summary",
            "summary": "2022 Annual Summary",
            "date_modified": "2023-04-19T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<p>最近前端已死的言论发酵很严重，我思考了不久，这里分享一下我的看法，比较悲观，只是个人观点，欢迎反驳。</p>\n<h3>入行无门槛</h3>\n<p>前端这个岗位，任何一个人都可以来干，学习资源网上都有，付费的不付费的。而且培训班众多，每年入行无数人。对比教师、律师、医生、金融、土木等等这些行业，前端基本等于无门槛。</p>\n<h3>简单</h3>\n<p>这个简单只是描述想要达到能干前端业务的水平比较简单，并不是说所有前端相关的技术都简单。</p>\n<p>其实前端在一些方向的确是有不小的难度。但是大部分的公司需要的前端其实只需要画画页面就好了。</p>\n<p>这一点去看招聘网站就能发现，需求最大往往是 3-5 年经验的工程师。</p>\n<h3>无意义的卷</h3>\n<p>目前的一个大趋势是，各家大厂都在实现自己的前端框架、实现自己的 webpack、实现自己的组件库、实现自己的微前端...而且都还在争相开源。</p>\n<p>其实大部分都是重复造轮子，创新有限，本质是 KPI 产物。</p>\n<p>当然，也有一些有创新的。但是大部分都是无意义的卷。在公司有裁员倾向的时候，这些岗位往往很容易被裁掉。</p>\n<h3>开源是双刃剑</h3>\n<p>开源社区互相讨论和学习，有助于统一规范和技术进步。但是开源也极大消除了技术壁垒，许多本应该是独门绝技的技巧，公开后价值就大打折扣。因为开源的关系，许多小公司就不再需要聘请太多的工程师，因为都可以用开源库很快速的实现。</p>\n<p>我目前的编码习惯，就是有问题的话就会去 Github 搜索类似功能的实现，直接去看别人的源码，基本都能解决问题。但是如果这是一个封闭的行业呢？那遇到问题就只能向有经验的人付费咨询，虽然不方便，但也真的形成了技术壁垒，而且能带来经济效应。</p>\n<h3>自己干掉自己</h3>\n<p>上面说的，现在崇尚开源。但是开源的代码不止会被人看到，还会被 AI 不断的训练学习，这样下去的话，在可见的未来 AI 绝对能替代相当一部分编码的工作。</p>\n<p>最近比较火的一个方向是低代码，很多新页面能用可视化页面快速搭建了，甚至直接设计图生成前端代码，那还需要那么多前端吗？做低代码方向可不就是在自己干掉自己。</p>\n<h3>前端已死？</h3>\n<p>前端是一份技术工作，然而这份技术会随着时间的发展而逐渐降低难度，而且技术本身没有太大的专业壁垒和门槛，又因为高薪而每年涌入大量的人来竞争。</p>\n<p>综合上面的看法，我觉得前端还没死，但是会逐渐迈向死亡。</p>\n<p>我觉得十年后，公司大量招聘的会是<strong>业务工程师</strong>，因为业务开发会变得很简单，不管是前端页面还是后端 curd。因为简单而且人多，所以也不会给予太高的薪酬。</p>\n<p>甚至悲观一点，这一类业务工程师，里面可能有相当一部分都是外包职位。因为本身做业务比较简单，外包也能做，而外包能显著降低公司成本，参考华为 OD。</p>\n<p>可能还会招聘一些<strong>基建工程师</strong>、<strong>架构师</strong>，做些基建和工具链的优化工作，但是数量会很少。</p>\n<h3>如何破局</h3>\n<p>业务 &gt; 技术，选择 &gt; 努力。</p>\n<p>我觉得不要把自己局限在前端的圈子里，可以花点时间关注下什么业务比较有发展前景，提前布局进入。业务和行业都是有生命周期的，只要能在行业早期进入，都会有收获的。业务和行业需要什么，就去学什么。</p>\n<p>我本人来说的话，我在 22 年初的跳槽中，拒了大厂的 offer 去了区块链，虽然我一直没有大厂经历，但目前看来是不后悔的。</p>\n<p>因为区块链还很早期，能感受到行业内还是比较缺人的，有很多场景可以做，如果发展起来的话，绝对是能吃到红利的。</p>\n<p>当然，区块链也可能飞不起来。飞不起来的话那就换个能飞起来的，保持学习，把自己当创业者，永远在路上。</p>\n<h3>35 岁危机？</h3>\n<p>程序员的 35 岁危机看来是国内特有的。照着目前的发展，如果继续呆在国内的话，是很难避免了。</p>\n<p>有人说去国企，其实现在大部分国企也卷，而且国企卡年龄更严重。</p>\n<p>有人说去外企，外企其实在逐步退出国内，而且外企的裁员风险其实反而更高，因为不是总部。</p>\n<p>也有人说国内 remote 找海外的工作，比如在电鸭之类的社区。</p>\n<p>可行，但是报酬低，因为要跟印度、马来西亚、巴基斯坦、泰国之类的地区的人竞争，而且基本都是国外的外包，一个项目干完就失业了，需要重新再找。</p>\n<p>twitter 上有些独立开发者，但我觉得这种相当于自己创业了。</p>\n<p>所以我觉得，想要安稳打工的话，除了润，似乎没啥太好的办法。</p>\n<p>而且国外虽然没有 35 危机，但是裁员危机却是避不开的，并没有万全的法子。润只能减缓，治标不治本。</p>\n<h3>润？</h3>\n<p>润不润还是看个人选择吧，我觉得润出去只是去发达国家当普通人而已，因为本身是发达国家，所以生活质量、社会福利等等都有保证。</p>\n<p>我个人还是倾向于跟着工作走，如果工作需要润的话，我还是乐意去国外赚钱的。至于移民的话，目前没啥想法。</p>\n<p>而如果不润的话，就难以避免上面说到的35岁危机。所以该润就润。</p>\n<h3>现在</h3>\n<p>学好英语，为润做好准备。</p>\n<p>要卷，僧多粥少的情况下，唯有卷赢别人，自己才有饭吃。</p>\n<p>尽量在自己失业之前，赚够足够多的钱。</p>\n<p>多探索创业的可能性，既然打工早晚要失业，那么不如自己去当老板。</p>\n<p>想留在国内的话，还是要提前进入铁饭碗行业，旱涝保收。毕竟，铁饭碗才是这片土地的主流。</p>\n",
            "url": "https://clark-cui.top/posts/前端已死.html",
            "title": "前端已死",
            "summary": "前端已死",
            "date_modified": "2023-04-05T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>简介</h2>\n<p>whisper 是 openai 开源的字幕识别工具，可以识别字幕，翻译字幕，因为他英文翻译中文的效果一般，所以我一般就用它识别英文字幕</p>\n<h2>安装步骤</h2>\n<blockquote>\n<p>下面这些步骤基于 m1 pro</p>\n</blockquote>\n<h3>安装 python</h3>\n<p>在<a href=\"https://github.com/openai/whisper\">whisper 的 github</a>找到对应的 python 版本，目前是 3.9.9，然后去 python 官网下载对应版本的安装器安装即可</p>\n<h3>安装 ffmper</h3>\n<pre><code class=\"language-shell\"># on MacOS using Homebrew (https://brew.sh/)\nbrew install ffmpeg\n</code></pre>\n<h3>安装 whisper</h3>\n<pre><code class=\"language-shell\">pip install -U openai-whisper\n</code></pre>\n<p>这个时候 whisper 就可以用了，使用 help 查看可选命令</p>\n<pre><code class=\"language-shell\">whisper --help\n</code></pre>\n<pre><code class=\"language-shell\">--language en 是指生成英文字幕\n--task transcribe 是指生成字幕，translate是翻译字幕\n--model medium.en 是指用medium.en这个model，还有small、tiny...可选\n--output_format srt 是指产物格式，不输入默认生成所有格式\n--device mps 是指用什么渲染，一般可选cuda、mps、cpu(cuda是nvidia的gpu技术、mps是m1的gpu技术)\n</code></pre>\n<p>当然，这个时候只能用基础功能的 whisper，默认使用 cpu 渲染，默认使用 small 模型</p>\n<pre><code class=\"language-shell\">whisper test.mp4 --language en --task transcribe --output_format srt\n</code></pre>\n<h3>进阶</h3>\n<h4>使用 medium 模型</h4>\n<p>我们会发现，默认的 small 模型生成的字幕质量一般，所以我们想用 medium 模型，然而 whisper 在 m1 上自动下载 medium 模型的时候会报 ssl certificate 的错，这个时候我们可以手动下载来解决：</p>\n<p>我们访问 <a href=\"https://github.com/openai/whisper/blob/main/whisper/__init__.py\">这个地址</a>来找到 medium.en 这个模型的下载地址，手动下载后，放入<code>/Users/{username}/.cache/whisper</code>目录里即可</p>\n<pre><code class=\"language-shell\">whisper test.mp4 --language en --task transcribe --model medium.en --output_format srt\n</code></pre>\n<blockquote>\n<p>这个其实是 known issue,解决办法有两个，这里使用的第二种解决办法</p>\n<ol>\n<li>\n<p><a href=\"https://github.com/openai/whisper/discussions/734#discussioncomment-4491761\">https://github.com/openai/whisper/discussions/734#discussioncomment-4491761</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/openai/whisper/discussions/734#discussioncomment-4492259\">https://github.com/openai/whisper/discussions/734#discussioncomment-4492259</a></p>\n</li>\n</ol>\n</blockquote>\n<h4>使用 gpu 加快生成速度</h4>\n<p>我们会发现用 cpu 的生成速度慢的不行，whisper 是支持使用 gpu 生成的，gpu 的生成速度比 cpu 快不少，而且 nvidia 的 cuda 和苹果 m1 的 mps 都是性能很高的 gpu 渲染技术。</p>\n<p>首先，我们需要安装 pytorch</p>\n<pre><code class=\"language-shell\">pip3 install torch torchvision torchaudio\n</code></pre>\n<p>然后我们就可以在 m1 芯片的笔记本上使用 mps 渲染了吗?</p>\n<pre><code class=\"language-shell\">whisper test.mp4 --language en --task transcribe --model medium.en --output_format srt --device mps\n</code></pre>\n<p>哈哈，天真，报错啦！</p>\n<p>大概看了一下，就是 whisper+pytorch+m1 的 mps 现在基本等于不可用，有人说安装最新 nightly 版本的 pytorch 可以解决，然而并没有</p>\n<p>目前普遍的解决方案是使用<a href=\"https://github.com/ggerganov/whisper.cpp\">cpp 版本的 whisper</a>,这里我就不折腾了，用 cpu 就用 cpu 吧，慢一点又不是不能用...如果真的有需要大批量的翻译字幕，还是用 pc+nvidia 的显卡比较靠谱</p>\n<h4>总结</h4>\n<pre><code class=\"language-shell\">whisper test.mp4 --language en --task transcribe --model medium.en --output_format srt\n</code></pre>\n<h3>备注</h3>\n<p>上面生成了英文字幕，如果想要中文字幕，或者中英双语字幕，那么可以使用<a href=\"https://www.nikse.dk/subtitleedit/online\">免费机翻</a>,生成中文字幕后，下载下来，再使用字幕合成工具，把中英文合二为一,可以<a href=\"https://sspai.com/post/76899\">参考这里</a></p>\n<p>不过，上面这种方式翻译质量堪忧，目前翻译质量比较好的还是 deepl 和 gpt，deepl 和 gpt 都需要付费，我觉得有英文字幕就行了吧，不懂的单词现查，就当作学英语了</p>\n<p>或许有人会有疑问，为啥不用 whisper 的 translate 功能？主要有 2 个原因，第一是慢，第二是 medium 模型的中文翻译水平比较一般，如果需要中文翻译的话，还是使用别的翻译软件比较靠谱，比如上文提到的 deepl 和 gpt。当然，如果你的 pc 性能足够的话，也可以直接运行最新的 large-2 模型，中文翻译质量应该高不少</p>\n",
            "url": "https://clark-cui.top/posts/使用whisper生成字幕.html",
            "title": "使用whisper生成字幕",
            "summary": "使用whisper生成字幕",
            "date_modified": "2023-03-22T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>背景</h2>\n<p>我们和链上交互的时候，如果有从链上读取信息的需求，那么就需要去请求 rpc 节点。如果我们需要从一个合约的多个方法，或者是多个合约上获取信息，就需要对这些分别调用，每一个调用都会发送一个 rpc 请求。<br>\n基于此，如果我们再有类似，监听区块变化去更新数据的需求，那么 rpc 请求会非常的多，影响性能，甚至有时候会被某些节点屏蔽掉<br>\n同时，如果数据有很强的时效性，那么单独去请求，可能会导致返回的数据来源于不同的区块。</p>\n<h2>介绍</h2>\n<p>针对上面提到的问题，已经有人提出很好的解决方案，那就是 multicall<br>\n这减少了需要发送的单独的 JSON RPC 请求的数量（如果使用像 Infura 这样的远程节点，特别有用），同时也提供了保证，所有返回的值都来自同一个区块（像原子读取），并返回值的区块编号（给他们重要的背景，所以如果来自过时的节点，来自旧区块的结果可以被忽略）</p>\n<h2>实现原理</h2>\n<h3>合约</h3>\n<p>一般用的 makerdao 的那套标准，主要的有 3 个合约：</p>\n<p><strong>Multicall:</strong></p>\n<p>最基础的 multicall，包含一个批量调用的方法 aggregate</p>\n<pre><code class=\"language-Solidity\">// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\ncontract Multicall {\nstruct Call {\naddress target;\nbytes callData;\n}\n\n    function aggregate(Call[] calldata calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\n        blockNumber = block.number;\n        returnData = new bytes[](calls.length);\n        for (uint256 i = 0; i &lt; calls.length; i++) {\n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n            require(success);\n            returnData[i] = ret;\n        }\n    }\n\n...\n}\n</code></pre>\n<p><strong>Multicall2:</strong></p>\n<p>aggregate 方法里的<code>require(success)</code>这行代码，表示该方法只允许批量调用均成功才会返回数据，只要有一个调用失败，整个方法就会抛出错误。</p>\n<p>所以 Multicall2,在继承了 Multicall 的所有方法后，额外增加了 tryBlockAndAggregate 方法，该方法允许传入一个 requireSuccess 的参数，来控制是否允许批量调用的失败</p>\n<pre><code class=\"language-Solidity\">function tryAggregate(bool requireSuccess, Call[] calldata calls) public returns (Result[] memory returnData) {\nreturnData = new Result[](calls.length);\nfor (uint256 i = 0; i &lt; calls.length; i++) {\n(bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n\n            if (requireSuccess) {\n                require(success, &quot;Multicall2 aggregate: call failed&quot;);\n            }\n\n            returnData[i] = Result(success, ret);\n        }\n    }\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls) public returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        blockNumber = block.number;\n        blockHash = blockhash(block.number);\n        returnData = tryAggregate(requireSuccess, calls);\n    }\n\n    function blockAndAggregate(Call[] calldata calls) public returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\n    }\n</code></pre>\n<p><strong>Multicall3:</strong></p>\n<p>这是推荐的版本。</p>\n<p>同样，Multicall3 向下兼容 Multicall2，继承了 Multicall2 的所有方法。它和 Multicall2 不一样的点在于</p>\n<ol>\n<li>它允许控制每一项调用是否允许失败，而不是像 Multicall2 那样只能控制所有的调用是否允许失败。这个功能通过 aggregate3 方法实现，传入的 calldata 里可以拼入 allowFailure，来控制每一项调用是否开启允许失败。</li>\n<li>但它的使用成本更低，因为它做了 gas 消耗的优化</li>\n</ol>\n<pre><code class=\"language-Solidity\">function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\nuint256 length = calls.length;\nreturnData = new Result[](length);\nCall3 calldata calli;\nfor (uint256 i = 0; i &lt; length;) {\nResult memory result = returnData[i];\ncalli = calls[i];\n(result.success, result.returnData) = calli.target.call(calli.callData);\nassembly {\n// Revert if the call fails and failure is not allowed\n// `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\nif iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\n// set &quot;Error(string)&quot; signature: bytes32(bytes4(keccak256(&quot;Error(string)&quot;)))\nmstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n// set data offset\nmstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n// set length of revert string\nmstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\n// set revert string: bytes32(abi.encodePacked(&quot;Multicall3: call failed&quot;))\nmstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\nrevert(0x00, 0x64)\n}\n}\nunchecked { ++i; }\n}\n}\n</code></pre>\n<h3>前端调用</h3>\n<blockquote>\n<p>前端调用示例基于 ethers.js</p>\n</blockquote>\n<p><strong>使用 Multicall:</strong></p>\n<pre><code class=\"language-TypeScript\">export async function all&lt;T extends any[] = any[]&gt;(\ncalls: ContractCall[],\nmulticallAddress: string,\nprovider: Provider,\n): Promise&lt;T&gt; {\nconst multicall = new Contract(multicallAddress, multicallAbi, provider);\nconst callRequests = calls.map(call =&gt; {\nconst callData = Abi.encode(call.name, call.inputs, call.params);\nreturn {\ntarget: call.contract.address,\ncallData,\n};\n});\nconst response = await multicall.aggregate(callRequests);\nconst callCount = calls.length;\nconst callResult = [] as T;\nfor (let i = 0; i &lt; callCount; i++) {\nconst outputs = calls[i].outputs;\nconst returnData = response.returnData[i];\nconst params = Abi.decode(outputs, returnData);\nconst result = outputs.length === 1 ? params[0] : params;\ncallResult.push(result);\n}\nreturn callResult;\n}\n</code></pre>\n<p><strong>使用 Multicall3:</strong></p>\n<pre><code class=\"language-TypeScript\">export async function multicall({\nallowFailure = true,\nchainId,\ncontracts,\noverrides\n}) {\nconst multicallContract = getContract({\naddress: chain.contracts.multicall3.address,\nabi: multicallABI,\nsignerOrProvider: provider\n});\n\nconst calls = contracts.map(({ address, abi, functionName, ...config }) =&gt; {\nconst { args } = config || {};\nconst contract = getContract({ address, abi });\nconst params = args ?? [];\nconst normalizedFunctionName = normalizeFunctionName({\ncontract,\nfunctionName,\nargs\n});\ntry {\nconst contractFunction = contract[normalizedFunctionName];\nif (!contractFunction)\nlogWarn(\n`&quot;${normalizedFunctionName}&quot; is not in the interface for contract &quot;${address}&quot;`\n);\nconst callData = contract.interface.encodeFunctionData(\nnormalizedFunctionName,\nparams\n);\nreturn {\ntarget: address,\nallowFailure,\ncallData\n};\n} catch (err) {\nif (!allowFailure) throw err;\nreturn {\ntarget: address,\nallowFailure,\ncallData: '0x'\n};\n}\n});\n\nconst params = [...[calls], ...(overrides ? [overrides] : [])];\nconst results = await multicallContract.aggregate3(...params);\nreturn results.map(({ returnData, success }, i) =&gt; {\nconst { address, abi, functionName, ...rest } = contracts[i];\n\n    const contract = getContract({\n      address,\n      abi: abi as Abi\n    });\n    const args = rest.args as unknown[];\n    const normalizedFunctionName = normalizeFunctionName({\n      contract,\n      functionName,\n      args\n    });\n\n    if (!success) {\n      let error;\n      try {\n        contract.interface.decodeFunctionResult(\n          normalizedFunctionName,\n          returnData\n        );\n      } catch (err) {\n        error = new ContractMethodRevertedError({\n          address,\n          args,\n          chainId: chain.id,\n          functionName: normalizedFunctionName,\n          errorMessage: (err as Error).message\n        });\n        if (!allowFailure) throw error;\n        logWarn(error.message);\n      }\n      return null;\n    }\n\n    if (returnData === '0x') {\n      const error = new ContractMethodNoResultError({\n        address,\n        args,\n        chainId: chain.id,\n        functionName: normalizedFunctionName\n      });\n      if (!allowFailure) throw error;\n      logWarn(error.message);\n      return null;\n    }\n\n    try {\n      const result = contract.interface.decodeFunctionResult(\n        normalizedFunctionName,\n        returnData\n      );\n      return Array.isArray(result) &amp;&amp; result.length === 1 ? result[0] : result;\n    } catch (err) {\n      const error = new ContractResultDecodeError({\n        address,\n        args,\n        chainId: chain.id,\n        functionName: normalizedFunctionName,\n        errorMessage: (err as Error).message\n      });\n      if (!allowFailure) throw error;\n      logWarn(error.message);\n      return null;\n    }\n\n});\n}\n</code></pre>\n<h2>问题</h2>\n<ol>\n<li>为什么 <a href=\"https://wagmi.sh/core/actions/multicall#allowfailure-optional\">wagmi</a> 的 multicall 所传入的 allowFailure 并不可以每一个调用独立配置？</li>\n</ol>\n<p>答：是这个库故意这么封装的，可以看到他把 multicall 方法接收的参数 allowFailure 在遍历 calls 的时候拼接进去了</p>\n<p>2 为什么上面提到的都是读方法，写方法可以 multicall 吗？</p>\n<p>答：可以。但是一般不建议这么做:</p>\n<ul>\n<li>一般写方法的聚合会在合约端实现，并不需要前端调用的时候去 multicall。</li>\n<li>如果需要在合约里调用合约，那么一般合约会单独封装方法来实现。这么做可以对消耗 gas 实现优化</li>\n<li>直接 multicall 粗暴的调用不安全，因为这个时候，msg.sender 、 msg.value、tx.origin 等值可能会因为上下文不一样而导致执行结果不符合预期。<br>\n所以大部分封装了 multicall 的库都会提示，他们的 multicall 方法只支持 <a href=\"https://docs.ethers.org/v5/api/contract/contract/#Contract--readonly\">read-only</a> 的聚合调用</li>\n</ul>\n<ol start=\"3\">\n<li>Dex 的首次 swap，需要先授权，再进行 swap，那这一步可以通过 multicall，来实现授权转账合并为 1 步吗？</li>\n</ol>\n<p>答：不行。因为转账这步操作依赖授权的结果，这俩动作并不能在一个区块上同时进行。转账需要在授权的结果上链之后，才可以进行</p>\n<h2>reference</h2>\n<ol>\n<li><a href=\"https://github.com/cavanmflynn/ethers-multicall/blob/master/src/call.ts\">https://github.com/cavanmflynn/ethers-multicall/blob/master/src/call.ts</a></li>\n<li><a href=\"https://github.com/Destiner/ethcall/blob/master/src/call.ts\">https://github.com/Destiner/ethcall/blob/master/src/call.ts</a></li>\n<li><a href=\"https://github.com/wagmi-dev/wagmi/blob/main/packages/core/src/actions/contracts/multicall.ts#L110\">https://github.com/wagmi-dev/wagmi/blob/main/packages/core/src/actions/contracts/multicall.ts#L110</a></li>\n<li><a href=\"https://github.com/makerdao/multicall\">https://github.com/makerdao/multicall</a></li>\n<li><a href=\"https://github.com/mds1/multicall\">https://github.com/mds1/multicall</a></li>\n</ol>\n",
            "url": "https://clark-cui.top/posts/合约的multicall.html",
            "title": "合约的multicall",
            "summary": "合约的multicall",
            "date_modified": "2023-03-20T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>前言</h3>\n<p>我们在第一次使用Uniswap这一类的DEX的时候，在swap之前，会需要进行approve的操作。这让人很疑惑，心里发问，我直接转账不就完了吗？授权啥？</p>\n<p>今天，我们来研究下，为什么swap之前需要approve</p>\n<h3>协议</h3>\n<p>首先，我们以Ethereum为例，转账的都是ERC-20代币，那么我们就来直接看<a href=\"https://eips.ethereum.org/EIPS/eip-20\">ERC-20的协议标准</a></p>\n<p>相关的方法事件有：</p>\n<pre><code class=\"language-solidity\">function balanceOf(address _owner) :  //查询余额\nfunction transfer(address _to, uint256 _value) //转账\nfunction transferFrom(address _from, address _to, uint256 _value) // 转账\nfunction approve(address _spender, uint256 _value) // 授权\nfunction allowance(address _owner, address _spender)  // 查询授权额度\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value) // Transfer事件\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value) //Approval事件\n\n</code></pre>\n<h3>代码</h3>\n<p>然后，我门直接上代码，看 <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9b3710465583284b8c4c5d2245749246bb2e0094/contracts/token/ERC20/ERC20.sol\">openzeppelin的实现</a></p>\n<p>首先是全局变量和allowance和balanceOf方法</p>\n<pre><code class=\"language-solidity\"> // 首先是两个全局变量map\n mapping (address =&gt; uint256) private _balances; // 存储地址address的余额\n mapping (address =&gt; mapping (address =&gt; uint256)) private _allowed;// 存储地址address1对address2的授权额度\n\n// allowance方法\n  function allowance(\n    address owner,\n    address spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return _allowed[owner][spender];   // 返回_allowed 这个map中存储的：ownder对spender的授权额度\n  }\n  \n// balanceOf方法\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner]; //返回_balances 这个map中存储的：ownder的余额\n  }\n\n\n</code></pre>\n<p>balanceOf方法，就是接收一个账户地址，返回该地址中这个ERC-20 token的余额</p>\n<p>allowance方法，有两个参数，owner和spender，返回owner对spender的针对这个ERC-20 token的授权额度</p>\n<p>然后是涉及到转账的方法，分别是transfer和transferFrom</p>\n<pre><code class=\"language-solidity\">// transfer方法\n function transfer(address to, uint256 value) public returns (bool) {\n    require(value &lt;= _balances[msg.sender]);  // transfer的数量value要 &lt;= msg.sender的余额\n    require(to != address(0));   // 接收方to地址不能为空\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value); // msg.sender的余额扣除transfer的数量value\n    _balances[to] = _balances[to].add(value); // 接收方to地址的余额增加transfer的数量value\n    emit Transfer(msg.sender, to, value); // 触发Transfer事件\n    return true;\n  }\n  \n  // transferFrom方法\n    function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    public\n    returns (bool)\n  {\n    require(value &lt;= _balances[from]);  // transfer的数量value要 &lt;= 发送方from的余额\n    require(value &lt;= _allowed[from][msg.sender]); // transfer的数量value要 &lt;= 发送方from对msg.sender的授权额度\n    require(to != address(0)); //接收方to地址不为空\n\n    _balances[from] = _balances[from].sub(value); //发送方from的余额扣除transfer的数量value\n    _balances[to] = _balances[to].add(value); //接收方to的余额增加transfer的数量value\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); // 发送方from对msg.sender的授权额度扣除transfer的数量value\n    emit Transfer(from, to, value); // 触发Transfer事件\n    return true;\n  }\n</code></pre>\n<p>transfer方法，就是向to地址转账value个token，前提是发送方的余额要大于转账个数value</p>\n<p>transferFrom方法，就是从from地址向to地址转账value个token，前提是发送方from的余额要大于转账个数value，同时转账的个数value要小于发送方from对msg.sender的授权额度。</p>\n<p>大家可能会有疑问，msg.sender不就是from吗？其实不是，钱是从from这里出去到to这里的，但是发送这个动作并不是from做出的，而是一个第三方中间人(通常是合约)来做的。可以这么理解，from事先给了msg.sender自己金库的钥匙，允许msg.sender可以去from的金库里取钱，transferFrom这个动作其实就是msg.sender从from的金库里取钱发送给了to。</p>\n<p>from把自己的金库钥匙给msg.sender这个动作，就是授权</p>\n<pre><code class=\"language-solidity\">  function approve(address spender, uint256 value) public returns (bool) {  //接受两个参数，spender（被授权者）、value(授权额度)\n    require(spender != address(0));  // 被授权者的地址不为空\n\n    _allowed[msg.sender][spender] = value;  //msg.sender对spender授权value额度\n    emit Approval(msg.sender, spender, value); //触发Approval事件\n    return true;\n  }\n</code></pre>\n<p>上面的msg.sender就是当前调用ERC-20合约方法的人，这个人可以是一个普通账户，也可以是一个合约地址。</p>\n<h3>总结</h3>\n<p>一般来说，transfer方法是给普通账户用的。假设当a要向一个目标地址b转账某个ERC-20代币的时候，只需要调用这个ERC-20代币的transfer方法即可，此时msg.sender，也就是方法的调用者，就是这个普通账户a。</p>\n<p>与之对应的,transferFrom方法一般是给合约用的。首先a授权给合约b转走token的权利，a授权b的时候，msg.sender是方法approve的调用者，也就是a。</p>\n<p>然后合约b会调用transferFrom给c转账，这个时候msg.sender就是transferFrom的调用者，也就是合约b。</p>\n<p>授权和转账这两步，都是需要收取gas fee的</p>\n<p>为什么合约需要这么做呢？一般情况下，a调用transfer方法给b转账1个usdt，然后就结束了。</p>\n<p>但是如果在DEX的场景下，a想要把1个usdt换成1个usdc。在这种情况下，a在向swap合约b转账1个usdt之后，<strong>b并不会得到任何的通知</strong>（因为<strong>ERC-20标准并没有规定一笔转账会通知到任何人</strong>），所以b并不会及时地给a转账1个usdc。</p>\n<p>这个时候就需要transferFrom登场了，a先授权给合约b转走自己usdt的权利。然后a再去调用合约b的转账方法，合约b的转账方法会调用usdt的transferFrom方法直接从a那里拿到1个usdt，只要transferFrom方法成功，合约b就知道自己一定从a那里收到了1个usdt，所以合约b就可以给a转账1个usdc</p>\n<h3>前端实现</h3>\n<p>合约逻辑清楚了，其实前端的实现就很简单了,这里贴一些伪代码吧</p>\n<pre><code class=\"language-javascript\">首先声明一些变量\n// 连接钱包地址 from\n// 转账到的地址 to\n// 调用的swap合约 SWAP\n// 转账的token USDT,它的合约地址 U\n// 转账USDT的数量 amount\n\n// 调用U的合约方法allowance，判断allowance的返回值是否为0；如果不为0则直接调用SWAP合约的swap方法转账；如果allowance为0，则调用U的approve方法给SWAP合约授权,再调用SWAP合约的转账方法\n   const allowed =\tallowance(from，SWAP)\n\t\tif(allowed&lt; amount){ //这里一般是写allowed === 0，因为一般授权的都是最大数量，即时这个数量会随着每次transfer而减少，但是也几乎不可能出现allowed&lt;amount的情况\n\t\t\tapprove(SWAP,最大数量)\n\t\t}else{\n\t\t\ttransfer(from,to,amount)\n\t\t}\n\n// 当然，SWAP合约的转账方法，本质上还是调用U的transferFrom方法，并在成功后会让to给from转账,其实是两笔转账(如果有流动性池，那可能是多笔)\n</code></pre>\n<h4>引申问题</h4>\n<ol>\n<li>\n<p>既然我们可以给一个合约授权，让他可以有转走我们的token的权利。那么我们可以取消授权吗？</p>\n<p>答案是可以，我们只需要再次调用approve方法，把approve的数量设为0即可。一些插件钱包已经实现了这个功能。</p>\n</li>\n<li>\n<p>ETH虽然是ethereum的原生代币，但是ETH并不是ERC-20代币，那么我们该怎么在ethereum上转账ETH呢？</p>\n<p>答案是直接转即可，不需要授权。</p>\n</li>\n<li>\n<p>假如想要实现像DEX这样的使用场景，那么只有两种办法，一种就是用WETH(ERC-20)，另一种就是合约做兼容，专门处理ETH的SWAP，普遍来说就是再写一个合约方法，SWAP、SWAPETH。</p>\n</li>\n</ol>\n<h3>references</h3>\n<p><a href=\"https://ethereum.stackexchange.com/questions/98892/what-is-the-difference-between-transfer-and-trasnferfrom-and-when-should-i-u\">what-is-the-difference-between-transfer-and-trasnferfrom</a></p>\n<p><a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9b3710465583284b8c4c5d2245749246bb2e0094/contracts/token/ERC20/ERC20.sol\">ERC-20 implementation</a></p>\n<p><a href=\"https://eips.ethereum.org/EIPS/eip-20\">ERC-20的协议标准</a></p>\n<p><a href=\"https://ethereum.stackexchange.com/questions/28233/how-to-do-approve-and-transferfrom-for-ether\">how-to-do-approve-and-transferfrom-for-ether</a></p>\n<p><a href=\"https://docs.openzeppelin.com/contracts/4.x/erc20\">实现自己的ERC-20</a></p>\n",
            "url": "https://clark-cui.top/posts/为什么DEX需要授权.html",
            "title": "为什么DEX需要授权?",
            "summary": "为什么DEX需要授权?",
            "date_modified": "2023-02-16T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>流行词</h3>\n<h5>HODL</h5>\n<p>hold on for dear life (永远拿住一个币)</p>\n<h5>BAG HOLDER</h5>\n<p>坚定地持有币的人</p>\n<h5>REKT</h5>\n<p>wrecked(持有大量暴跌的货币的人)</p>\n<h5>Whale</h5>\n<p>巨鲸(大量持有加密资产的人)</p>\n<h5>BEARWHALE</h5>\n<p>指的是看空的大户</p>\n<h5>FUD</h5>\n<p>Fear uncertainty doubt(恐惧、不确定性、怀疑)</p>\n<h5>FOMO</h5>\n<p>fear of missing out(很害怕错过这次机会，一般指在币价上扬的时候，忙着追涨的人)</p>\n<h5>TO THE MOON/MOONING</h5>\n<p>飞涨到了月球</p>\n<h5>VAPORWARE</h5>\n<p>空气币、资金盘、垃圾币、庄家币</p>\n<h5>SHIL</h5>\n<p>指为了一己私利去推广资金盘的人，雇佣骗子</p>\n<h5>ATH</h5>\n<p>All time high(一般是指币价涨破历史新高)</p>\n<h5>PUMP AND DUMP</h5>\n<p>一般指庄家操纵市场，人为的把某个资产的价格拉高，然后高价卖出获利的行为</p>\n<h3>区块链的不可能三角</h3>\n<p>去中心化、安全性、性能。这三个指标没有办法都达到很高</p>\n<h3>软硬分叉</h3>\n<p>软硬分叉指的是区块链升级的方式。软分叉指向前兼容，硬分叉指不向前兼容，硬分叉升级后会分叉成两条链，一条由运行原来的客户端的节点来支持，一条由运行新的客户端的节点来支持。</p>\n<h3>layer0</h3>\n<p>一般指区块链的底层协议，就是layer1的底层的基础设施，不同的公链他的底层会有不同</p>\n<h3>layer1</h3>\n<p>一般指公链，比如比特币、以太坊、BSC、Solana、Polkadot、OKC</p>\n<h3>layer2</h3>\n<p>layer2指的是基于layer1(一般是基于以太坊)而运行的区块链。目的是为了解决以太坊的拥堵问题，把复杂的交易和计算放到layer2进行，再把结果返回layer1，使用layer1的共识和安全机制。比如Optimism、Polygon(MATIC)</p>\n<p>layer2方案一般分为</p>\n<ul>\n<li>rollup\n<ul>\n<li>optimistic rollup</li>\n<li>zk rollup</li>\n</ul>\n</li>\n<li>state channel（状态通道）</li>\n<li>Plasma</li>\n</ul>\n<p><a href=\"https://blog.chain.link/what-is-a-layer-2-zh/\">https://blog.chain.link/what-is-a-layer-2-zh/</a></p>\n<h4>闪电网络</h4>\n<p>闪电网络是一种比特币的layer2解决方案。</p>\n<p>比特币最初的设计更倾向于去中心化和安全性，所以性能很差，每秒只能进行7笔交易(tps是7)。</p>\n<p>所以设计出了闪电网络，基于状态通道，先通过线下通道来执行交易，最后把结果上链。</p>\n<p><a href=\"https://academy.binance.com/zh/articles/blockchain-layer-1-vs-layer-2-scaling-solutions\">https://academy.binance.com/zh/articles/blockchain-layer-1-vs-layer-2-scaling-solutions</a></p>\n<h3>侧链</h3>\n<p>侧链很类似layer2。侧链和L2的主要区别是，L2继承L1主网络的安全性，而侧链则依赖于自己的安全性。侧链比L2更独立，有自己的共识机制。</p>\n<p>layer2和侧链都属于公链常见的扩容方案。</p>\n<p><a href=\"https://www.binance.com/zh-CN/news/top/7115028\">https://www.binance.com/zh-CN/news/top/7115028</a></p>\n<h3>什么是WETH</h3>\n<p>其实是wrapped eth。</p>\n<p>以太坊基础的协议有ERC-20 TOKEN STANDARD，以太坊上运行的DAPP一般都会发行满足ERC-20的token，这些token统称为ERC-20代币。因为都是基于ERC-20协议的，所以互相是互通的</p>\n<p>但是ETH的原生代币(native token)ETH却并不满足ERC-20标准，所以不能与ERC-20代币互通，并不利于DAPP的开发，所以开发者创造出了一个满足ERC-20的新代币WETH，来实现互通。</p>\n<p>WETH与ETH是1:1锚定的，由权威的第三方来通过智能合约的形式质押ETH和铸造WETH(返回ETH，销毁WETH)来实现，当然这个比例根据市场会有一定的波动，甚至会有风险</p>\n<blockquote>\n<p>同理：</p>\n<ol>\n<li>WBTC，就是把BTC这条公链的BTC代币纳入erc-20的体系，来在以太坊的DAPP里互通。</li>\n<li>OKC上的K资产，指的就是把其他公链上的代币，用类似的形式在OKC上铸造一个新的币，满足OKC的代币体系来实现互通。常见的K资产有BTCK、LTCK、ETHK</li>\n</ol>\n</blockquote>\n<h3>ENS</h3>\n<p>ethereum name service</p>\n<p>诞生原因：钱包地址太长，难记，容易出现转账转错的情况</p>\n<p>所以诞生出了ens替代钱包地址，更简洁、不容易出错，转账的时候直接填写ens</p>\n<p>ens相比传统的域名dns解析的区别是:ens是去中心化的</p>\n<p>购买的域名是有商品价值的，好的域名可以挂出去，会被人高价抢购。</p>\n<h3>MEV</h3>\n<p>Maximal Extractable Value 矿工可开采价值</p>\n<p>指的是在创建新区块时增删交易或对交易进行重新排序的策略。 MEV旨在赚取尽可能多的额外利润。 由于区块生产者有能力选择和排序交易，因此最适合采取这一策略</p>\n<p><a href=\"https://ethereum.org/zh/developers/docs/mev/\">https://ethereum.org/zh/developers/docs/mev/</a></p>\n",
            "url": "https://clark-cui.top/posts/区块链科普2.html",
            "title": "区块链科普2",
            "summary": "区块链基础知识",
            "date_modified": "2023-02-13T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>优化的原因</h3>\n<p>react 里的一个基本常识是 re-render：当一个组件里的某个状态改变的时候，他会重新渲染，也就是重新执行所有组件代码，包括它的子组件。</p>\n<p>所以会带来很多不必要的重新渲染。</p>\n<h3>useMemo</h3>\n<p>useMemo 的基本理念是，它允许我们在渲染之间 &quot;记住 &quot;一个计算值</p>\n<h4>使用的场景举例</h4>\n<pre><code class=\"language-tsx\">function App() {\n  const [selectedNum, setSelectedNum] = React.useState(100);\n  const time = useTime();\n\n  const allPrimes = React.useMemo(() =&gt; {\n    const result = [];\n\n    for (let counter = 2; counter &lt; selectedNum; counter++) {\n      if (isPrime(counter)) {\n        result.push(counter);\n      }\n    }\n\n    return result;\n  }, [selectedNum]);\n\n   return (\n    &lt;-省略dom-&gt;\n   )\n</code></pre>\n<p>这里 App 组件里有一个状态 selectedNum,还有一个自定义 hook 导出的状态 time。假如不使用 useMemo 包裹 allPrimes，那么每当 time 变化的时候，就会重新执行 allPrimses 里面的代码，造成浪费；然而我们的 allPrimes 其实只跟 selectedNum 相关，所以我们这里用 useMemo 缓存函数包裹后，里面的代码就只会在 selectedNum 变化时执行，而不受 App 组件的 re-render 影响。</p>\n<p>当然，这里也可以有其他的写法，我们可以把 allPrimes 和 selectedNum 包括它的 dom 合并成一个子组件，time 和它的 dom 也合并成一个子组件</p>\n<pre><code class=\"language-tsx\">function App(){\n\n  return(\n  \t&lt;Time /&gt;\n    &lt;AllPrimes /&gt;\n  )\n}\n</code></pre>\n<p>这样，他们的状态隔离开，也可以实现当 time 里面的状态改变的时候，不会影响别的代码去 re-render。</p>\n<p>但是，有时候，我们反而是需要把状态放到外部组件的，因为可能有别的组件也同样依赖这个状态。</p>\n<pre><code class=\"language-tsx\">function App(){\n  const time = useTime();\n  return(\n  \t&lt;Time time={time} /&gt;\n    &lt;AllPrimes /&gt;\n  )\n}\n</code></pre>\n<p>这样的话，当 App 组件的 time 状态变化的时候，其实同样会使 Time 组件和 AllPrimes 组件 re-render。这个时候，就可以使用 React.memo 来优化</p>\n<pre><code class=\"language-tsx\">const PureAllPrimes = React.memo(AllPrimes);\nfunction App(){\n  const time = useTime();\n  return(\n  \t&lt;Time time={time} /&gt;\n    &lt;PureAllPrimes /&gt;\n  )\n}\n</code></pre>\n<p>React.memo 可以把一个组件变成 pure component，pure component 只有在 props 变化的时候，才会 re-render；</p>\n<p>当然，也可以在 AllPrimes 组件里，导出的时候去使用 React.memo</p>\n<pre><code class=\"language-tsx\">export default React.memo(AllPrimes);\n</code></pre>\n<p>我们来举另外一个例子</p>\n<p>Boxes 是一个 pure component,只有 boxes 变化的时候，才会 re-render;</p>\n<pre><code class=\"language-tsx\">function Boxes({ boxes }) {\n  return (\n    &lt;div className=&quot;boxes-wrapper&quot;&gt;\n      {boxes.map((boxStyles, index) =&gt; (\n        &lt;div key={index} className=&quot;box&quot; style={boxStyles} /&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n\nexport default React.memo(Boxes);\n</code></pre>\n<p>App 组件里引用了 Boxes,并声明常量 boxes 传入 Boxes 组件里</p>\n<pre><code class=\"language-tsx\">import Boxes from './Boxes';\n\nfunction App() {\n  const [name, setName] = React.useState('');\n  const [boxWidth, setBoxWidth] = React.useState(1);\n  const boxes = [\n    { flex: boxWidth, background: 'hsl(345deg 100% 50%)' },\n    { flex: 3, background: 'hsl(260deg 100% 40%)' },\n    { flex: 1, background: 'hsl(50deg 100% 60%)' },\n  ];\n\n  return (\n    &lt;&gt;\n      &lt;Boxes boxes={boxes} /&gt;\n      &lt;-省略dom-&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>当状态 name 变化的时候，我们期望只是 re-render App 组件，Boxes 组件不 re-render，然而 Boxes 组件仍然 re-render 了。这是因为，App 组件 re-render 的时候，重新生成了 boxes 变量，尽管是同样的值，但不是一个引用，所以导致了 Boxes 组件的 re-render</p>\n<p>要解决这个问题，只需要使用 useMemo 包裹一下即可</p>\n<pre><code class=\"language-tsx\">const boxes = React.useMemo(() =&gt; {\n  return [\n    { flex: boxWidth, background: &quot;hsl(345deg 100% 50%)&quot; },\n    { flex: 3, background: &quot;hsl(260deg 100% 40%)&quot; },\n    { flex: 1, background: &quot;hsl(50deg 100% 60%)&quot; },\n  ];\n}, [boxWidth]);\n</code></pre>\n<h3>UseCallback</h3>\n<p>它跟 useMemo 是一样的，都是缓存函数，但是他缓存的不是值，而是函数；</p>\n<h4>使用场景举例</h4>\n<p>MegaBoost 是一个 pure component,接受一个 callback 回调函数，只有当 callback 变化的时候才会 re-render</p>\n<pre><code class=\"language-tsx\">function MegaBoost({ handleClick }) {\n  console.log(&quot;Render MegaBoost&quot;);\n\n  return (\n    &lt;button className=&quot;mega-boost-button&quot; onClick={handleClick}&gt;\n      MEGA BOOST!\n    &lt;/button&gt;\n  );\n}\n\nexport default React.memo(MegaBoost);\n</code></pre>\n<p>App 组件里引用了 MegaBoost</p>\n<pre><code class=\"language-tsx\">function App() {\n  const [count, setCount] = React.useState(0);\n  function handleMegaBoost() {\n    setCount((currentValue) =&gt; currentValue + 1234);\n  }\n\n  return (\n    &lt;&gt;\n      Count: {count}\n      &lt;button\n        onClick={() =&gt; {\n          setCount(count + 1);\n        }}\n      &gt;\n        Click me!\n      &lt;/button&gt;\n      &lt;MegaBoost handleClick={handleMegaBoost} /&gt;\n    &lt;/&gt;\n  );\n}\n\nexport default App;\n</code></pre>\n<p>App 里声明了一个状态 count，一个函数 handleMegaBoost 并传入 MegaBoost 组件。</p>\n<p>当状态 count 变化的时候，会触发 App 组件的 re-render，并且重新生成一个新的 handleMegaBoost 传入 MegaBoost 组件，导致 MegaBoost 组件的 re-render。</p>\n<p>怎么解决这个问题呢？很简单，使用缓存函数即可</p>\n<pre><code class=\"language-tsx\">const handleMegaBoost = React.useMemo(() =&gt; {\n  return function () {\n    setCount((currentValue) =&gt; currentValue + 1234);\n  };\n}, []);\n</code></pre>\n<p>但是，一般我们更倾向于使用 useCallback</p>\n<pre><code class=\"language-tsx\">const handleMegaBoost = React.useCallback(() =&gt; {\n  setCount((currentValue) =&gt; currentValue + 1234);\n}, []);\n</code></pre>\n<h3>总结</h3>\n<ol>\n<li>组件里一些”经过复杂的逻辑计算而得到某个值“需要使用 Usememo 包裹，保证组件在 re-render 的时候不去重复计算</li>\n<li>父子组件的场景，子组件尽量用 React.memo 包裹成 pure component，避免父组件的 re-render 导致子组件跟着一起 re-render</li>\n<li>父子组件的场景，父组件声明变量传入子组件的时候，尽量用 useMemo 包裹，避免父组件 re-render 导致重新生成变量，而进一步导致子组件的 re-render</li>\n<li>父子组件的场景，副组件声明 callback 传入子组件的时候，尽量使用 useCallback 包裹，避免父组件 re-render 导致重新生成 callback，而进一步导致子组件的 re-render</li>\n</ol>\n<h3>引用链接</h3>\n<p><a href=\"https://www.joshwcomeau.com/react/usememo-and-usecallback/#use-case-2-preserved-references\">引用链接</a></p>\n",
            "url": "https://clark-cui.top/posts/react优化.html",
            "title": "React 简单优化",
            "summary": "React",
            "date_modified": "2022-09-03T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>简介</h3>\n<p>加密货币主要用到密码学中的两个功能</p>\n<ul>\n<li>哈希函数</li>\n<li>签名</li>\n</ul>\n<h3>Hash Function(又名散列函数)</h3>\n<p>密码学中用到的哈希函数被称为 cryptographic hash function，他有几个重要的性质</p>\n<h4>哈希碰撞阻力(Collision resistance)</h4>\n<p>如果 x != y, 有 H(x) == H(y), 则被称为哈希碰撞。一般来说哈希碰撞是很难避免，因为输入空间远大于输出空间。举个例子，假设我们使用 256 位的哈希值作为输出，那么输出空间就有 2^256，但是输入空间却没有限制，输入可能是无限大的。</p>\n<p>Collision resistence 并不是指不会有哈希碰撞，而是指没有高效的方法去人为地制造哈希碰撞。只能靠暴力求解，而这个在实际情况下是不可解的。<br>\n举个例子，给定一个 x，他的哈希值是 H(x)，找一个 y，让 H(x)=H(y)。没有什么高效地方法去找 y，大部分情况下只能暴力枚举(brute-force)<br>\n所以，这个性质可以用来生成 msg 的签名 H(msg)。用来检测对于 msg 的篡改，因为如果 msg 被修改，hash 值 H(msg)也会随之改变。<br>\n理论上来说，没有哪一个哈希函数可以在数学上证明是 collision resistance。只是长久以来这么多的密码学专家和数学家都没有找到高效地人为制造哈希碰撞的方法，所以我们可以从经验上认为他是 collision resistance 的。另外，有些哈希函数，以前我们认为他是 collision resistance 的，但是后来人们找到了人为制造哈希碰撞的方法，所以他就不是 collision resistance 的了，比如 MD5，破解网站示例。</p>\n<p>base64 是加密算法吗？</p>\n<p>答：不是，base64 是一种用文本表示的二进制编码方式，是可逆的。</p>\n<h3>隐藏(Hiding)</h3>\n<p>hiding 指的是哈希函数的计算过程是不可逆的。</p>\n<p>举个例子，给定一个值 x，可以算出他的哈希值 H(x)；但是如果给定一个哈希值 H(x)，并不能反推出他的输入值 x，也就是说，哈希值并不会泄漏有关他的输入值的任何信息，所以叫 hiding</p>\n<p>但是实际上，hiding 也并不是完全成立的，同样我们可以用暴力枚举的方法，把所有可能的输入值都计算一遍，找到与我们想找的哈希值一样的值，那就找到了原始值，破解了他的 hiding</p>\n<p>所以 hiding 这个属性成立的前提是，哈希函数的输入空间要足够大，让这种蛮力求解的方法不可行。而且输入的分布也要比较均匀 ，各种取值的可能性要是差不多的，因为如果取值集中在少数几个值，那么即使输入空间很大，那也是容易被破解的。</p>\n<p>这个 hiding 的性质可以与 collision resistance 结合起来，用来 digital commitment。</p>\n<p>举个例子，有一个人声称可以预测股市，那么有一种方法可以检验他是否预测准确，他提前一天公布自己的预测结果，当天去看他预测的对不对。这种方法看似可行，但是并不准确，假设他如果是一个名人，比如巴菲特，那么他提前公布预测结果可能会影响股市，因为大家会顺应他的预测结果去买卖股票。所以预测结果不能提前公开。</p>\n<p>有一种更好的方式，他提前一天写好自己的预测结果，密封起来，交给第三方保管，等到当天再拆开比对结果。</p>\n<p>但如何保证第三方的公正性？这里就可以使用哈希函数，他可以提前一天把自己的预测结果用哈希函数加密，然后把哈希值公布出来，当天再公开自己的预测结果。因为 hiding 的性质，大家不能通过他前一天公布的哈希值反推出他的预测结果，所以不会影响市场。而因为 collision resistance 的性质，大家能根据哈希值是否相等判断他当天公布的结果与前一天公布的是否一致。</p>\n<p>当然，在这个例子下，其实输入空间并不满足要求，hiding 并不成立，因为股票就几千只，输入空间不够大。所以我们可以用特殊方法来处理，取一个随机数(nonce)，计算哈希值的时候使用 H(msg+nonce)，来保证输入值足够随机，分布足够均匀，输入空间足够大。</p>\n<h4>puzzle friendly</h4>\n<p>意思是指，哈希值的计算事先是不可预测的，也就是说你单看一个输入值，你是不能判断他的哈希值大概长什么样，或者落在什么范围的。如果你想找一个输入值，他的哈希值落在某个范围内，那么你只能暴力枚举，顺着一个个计算他的哈希值。</p>\n<h5>挖矿</h5>\n<p>挖矿本质上就是为了找一个 nonce，这个 nonce 和区块的块头里的其他信息合在一起作为输入，得到一个哈希值，这个哈希值要小与等于一个目标值 target。也就是不停地用不同的随机数去计算，直到满足条件</p>\n<p>H(block header)&lt;=target.</p>\n<p>注意：nonce 本身就位于 block header 中</p>\n<p>Puzzle friendly 的意思也就是说，挖矿的过程，没有捷径，只能通过不停地计算来得到，这个过程也叫做工作量证明(proof of work)</p>\n<h5>difficult to solve, but easy to verify</h5>\n<p>虽然挖矿的过程需要大量的计算来找到符合条件的 nonce,但是当挖矿完成后，他发布出去，其他人要验证他的 nonce 是不是符合要求却很容易，只需要一次哈希计算即可</p>\n<h4>常见的 hash function</h4>\n<p>btc 中用的哈希函数是 SHA-256,sha 的意思是 secure hash algorithm,这个算法满足 collision resistance、hiding、puzzle friendly</p>\n<p>以太坊中的密码学哈希函数：Keccak-256,你会在以太坊的代码和文档中看到大量“SHA-3”的字样，这些多数都是指原始版本的 Keccak-256，而不是经过 SHA-3 标准化的 FIPS-202。</p>\n<p>cosmos 中常用的是 sha-256</p>\n<h3>签名</h3>\n<h4>账户管理</h4>\n<p>在本地创建一对公钥私钥(public key, private key)，就可以作为加密货币中的账户</p>\n<p>如何创建公钥和私钥？</p>\n<p>涉及到钱包的部分，简单来说，钱包分为非确定性钱包、确定性钱包、分层确定性钱包（HD Wallet）</p>\n<p>简单来说，就是先生成助记词，然后根据助记词生成种子，由种子生成私钥和一系列子私钥，我们从私钥开始，通过椭圆曲线乘法运算获得公钥</p>\n<p>为什么私钥生成公钥要用椭圆曲线乘法运算？</p>\n<p>答：因为椭圆曲线的乘法运算很容易，除法运算却很难，也就是说从私钥生成公钥很容易，但是从公钥反推私钥却几乎不可能。</p>\n<p>公钥私钥是来源于非对称加密算法(asymmetric encryption algorithm),与之对应的是对称加密算法(symmetric encryption algorithm)</p>\n<p>对称加密与非对称加密简单介绍</p>\n<p>公钥相当于你的银行账号，别人想要给你转账，只需要知道你的公钥就行了。私钥相当于你的银行密码，知道这个私钥，就可以把这个账号的钱转走</p>\n<p>前面我们提过，加密货币是不加密的，那这里的加密算法是用来干嘛的呢？实际上是用来签名的。</p>\n<p>举个例子，小红向小明转账 1 个 btc，当在链上广播的时候，大家如何判断真的是小红向小明转账了，而不是冒名交易呢？可以用签名的方式，小红向小明转账的时候，会用自己的私钥对交易信息进行加密（也就是签名），大家收到广播的时候，就对这条信息用小红的公钥进行解密，看是否是正确的交易信息</p>\n<p>既然账户是一对公私钥对，那么万一两个人生成了一样的公私钥对怎么办，那么就可以偷走另一外一个人的 btc？</p>\n<p>答：理论上可行，实际不可行，假设是 256 位的公私钥，产生相同公私钥对的可能性微乎其微。当然，这就需要要求有很好的随机源；比如，btc 系统中一般都是先对一串交易 message 取 hash，然后再对 hash 进行签名</p>\n<p>地址与公钥的关系？</p>\n<p>答：地址是唯一标识符，从公钥通过哈希函数计算而来，比如以太坊地址就是通过 Keccak-256。</p>\n<h4>签名</h4>\n<p>数字签名是一种由两部分组成的数学方案：第一部分是使用私钥（签名密钥）从消息（交易）创建签名的算法；第二部分是允许任何人在给定消息和公钥时验证签名合法性的算法<br>\n比较常见的签名算法结构如下所示</p>\n<p>使用另一个数学公式可以进行反向计算，也就是验证签名，不需要私钥，需要公钥(他的公式跟 Fsig 相对应，通常为椭圆曲线)</p>\n<p>比特币和以太坊中使用的数字签名算法是椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm,也就是 ECDSA</p>\n<p>Tendermint Core 中实现了多种数字签名算法，包括 ECDSA、Ed25519 以及 Sr25519，Tendermint Core 采用 Ed25519 数字签名算法完成共识投票过程中的投票，而 Cosmos-SDK 采用 ECDSA 进行交易的授权</p>\n",
            "url": "https://clark-cui.top/posts/密码学原理.html",
            "title": "密码学原理",
            "summary": "区块链基础知识",
            "date_modified": "2022-08-15T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>区块链现阶段的问题</h2>\n<blockquote>\n<p>本文内容主要来自《区块链架构与实现：Cosmos 详解》</p>\n</blockquote>\n<h3>开发周期长、技术门槛高</h3>\n<p>比特币网络面临这样的问题，以太坊的出现解决了这一类问题，主要是用 evm 虚拟机和智能合约开发 dapp 的形式来实现去中心化应用</p>\n<h3>资源消耗大、交易体验差</h3>\n<p>比特币和以太坊都面临这样的问题，主要是工作量证明（pow）、中本聪共识协议造成的。</p>\n<p>解决办法：可以用权益证明(pos)来替代 pow，用拜占庭容错共识协议(bft)或者实用拜占庭容错（practical Byzantine fault tolerance，PBFT）共识协议来代替中本聪共识协议。</p>\n<h3>链上扩容难与跨链通信难</h3>\n<p>比如 eth 链上部署了大量的 dapp 应用，都在争抢有限的计算资源。bch 通过增大每个区块的容量来提高链上交易处理速度的方式仅能带来有限的速度提高，eth2.0 的分片来实现链上交易并行处理的方式开发难度大，进展缓慢。所以构建多条链，并且多链通信是一种不错的解决方式。</p>\n<p>跨链通信的 3 种实现机制：散列锁、公证人和中继</p>\n<h2>Cosmos 的解决方案</h2>\n<p>为每一个区块链应用单独构建一条区块链，使用 IBC 协议来连接所有的区块链，通过 Tendermint Core、Cosmos-SDK 提供了区块链应用的开发框架，自动继承 Tendermint 共识协议以及 PoS 机制</p>\n<h3>Cosmos Hub</h3>\n<p>是第一个基于 Cosmos 构建的区块链，链上资产是 ATOM</p>\n<h3>Tendermint Core</h3>\n<p>将区块链系统自下而上拆解为 3 层：对等网络通信层、共识协议层以及上层应用层。</p>\n<ol>\n<li>\n<p>对等网络通信层：对等网络通信，确保交易、区块、共识协议的消息能够快速地在整个网络内广播。</p>\n</li>\n<li>\n<p>共识协议层：构建新的区块，并通过共识协议确保全网就区块内容（交易、上层应用状态等）达成共识。</p>\n</li>\n<li>\n<p>上层应用层：根据共识协议层构建的区块，通过 ABCI 与上层应用交互，执行区块中的交易并完成上层应用的状态更新</p>\n</li>\n</ol>\n<blockquote>\n<p>Tendermint Core 中提供了对等网络通信层与共识协议层的实现，并抽象出区块链应用接口（application blockchain interface，ABCI）来完成共识协议层与上层应用层的互动。</p>\n</blockquote>\n<p>使用的共识协议是 Tendermint 共识协议（pbft 共识协议改进而来）</p>\n<h3>Cosmos-SDK</h3>\n<p>Tendermint 团队构建了 Cosmos-SDK，实现了区块链场景中一系列的通用功能模块</p>\n<ul>\n<li>基础功能：账户管理与交易处理。</li>\n<li>auth 模块管理系统中的所有账户。</li>\n<li>bank 模块管理链上资产的转移。</li>\n<li>辅助功能：创世区块管理、链上状态一致性检查等。</li>\n<li>genutil 模块管理链的创世区块。</li>\n<li>supply 模块负责链上资产总量的管理。</li>\n<li>crisis 模块负责所有模块的不变量检查的管理。</li>\n<li>params 模块负责所有模块的参数管理。</li>\n<li>链上治理：基于提案的链上治理与网络升级。</li>\n<li>gov 模块负责链上治理机制。</li>\n<li>upgrade 模块负责链的升级。</li>\n<li>PoS：链上资产抵押、链上惩罚和奖励。</li>\n<li>staking 模块管理链上资产抵押。</li>\n<li>slashing 模块负责对验证者的被动作恶行为进行惩罚。</li>\n<li>evidence 模块负责对验证者的主动作恶行为进行惩罚。</li>\n<li>mint 模块负责链上资产的铸造。</li>\n<li>distribution 模块管理区块奖励的分发。</li>\n<li>IBC 协议：基于中继机制的跨链协议。</li>\n<li>ibc/core 模块负责跨链通信功能</li>\n</ul>\n<h3>基于 Tendermint Core 和 Cosmos-SDK 构建的区块链系统</h3>\n<p><img src=\"../public/WeChatf903a2cdf12631278f330b086b4b2fd8.png\" alt=\"\"></p>\n<h3>IBC 协议</h3>\n<p>IBC 协议是为了跨链而诞生的，是基于中继机制而实现的协议，原理是任意两个希望跨链通信的区块链可以依赖密码学证明技术向对方链证明自身链上发生了特定的事件。两条链之间的网络通信通过中继者（relayer）完成。</p>\n<p><img src=\"../public/WeChatd288ba57261eae3fef086b7f0abcff78.png\" alt=\"\"></p>\n",
            "url": "https://clark-cui.top/posts/Cosmos详解.html",
            "title": "Cosmos 详解",
            "summary": "cosmos",
            "date_modified": "2022-07-05T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>合约的组成</h3>\n<pre><code class=\"language-solidity\">// SPDX-License-Identifier:  MIT //开源协议\npragma solidity ^0.8.0; //编译器版本要大于0.8.0\ncontract Counter {  //定义合约\n\tuint public counter; //状态变量\n\tconstructor(){\n\t\tcounter =0;\n\t}\n\tfuntion count()public{ //合约函数\n\t\tcounter+=1;\n\t}\n}\n</code></pre>\n<h3>solidity 语言</h3>\n<ul>\n<li>静态类型、编译型、高级语言</li>\n<li>针对 EVM 专门设计 zh</li>\n<li>受 c++、javascript 等语言影响</li>\n<li>文档<a href=\"https://learnblockchain.cn/docs/solidity/\">中文</a>,<a href=\"https://docs.soliditylang.org/\">官方</a></li>\n</ul>\n<h3>solidity 数据类型</h3>\n<ul>\n<li>值类型\n<ul>\n<li>布尔、整型、定长浮点型、定长字节数组、枚举、函数类型、地址类型</li>\n<li>十六进制常量、有理数和整型常量、字符串常量、地址常量</li>\n</ul>\n</li>\n<li>引用类型\n<ul>\n<li>结构体</li>\n<li>数组</li>\n</ul>\n</li>\n<li>映射类型</li>\n</ul>\n<h4>整型</h4>\n<p>int/uint,uint8...uint256</p>\n<p>支持的运算符</p>\n<ul>\n<li>比较运算：&lt;=,&lt;,==,!=,&gt;=,&gt;</li>\n<li>位运算：&amp;,|,^(异或),~(位取反)</li>\n<li>算数运算：+,-,*,/,%（取余数）,**（幂）</li>\n<li>移位：&lt;&lt;(左移),&gt;&gt;(右移)</li>\n</ul>\n<p>在使用整型时，要特别注意整型的大小及所能容纳的最大值和最小值，如 uint8 的最大值是 0xff(255),最小值是 0</p>\n<p>从 solidity0.6.0 版本开始可以通过 Type(T).min 和 Type(T).max 获得整型的最小值和最大值</p>\n<h4>地址类型</h4>\n<p>solidity 使用地址类型来表示一个账号，地址类型有两种形式</p>\n<ul>\n<li>address:一个 20 字节的值</li>\n<li>address payable:表示可支付地址，与 address 相同也是 20 字节，不过它有成员函数 transfer 和 send</li>\n</ul>\n<p>成员函数</p>\n<ul>\n<li><code>&lt;address&gt;balance(uint256)</code>:返回地址的余额</li>\n<li><code>&lt;address payable&gt;transfer(uint256 amount)</code>:向地址发送以太币，失败时抛出异常</li>\n<li><code>&lt;address payable&gt;send(uint256 amount) returns(bool)</code>:向地址发送以太币，失败时返回 false</li>\n<li>3 个底层成员函数：call,delegatecall,staticcall 例如<code>&lt;address&gt;.call(bytes memory) returns (bool, bytes memory)</code>，通常用于合约交互，直接控制编码的方式调用合约函数</li>\n</ul>\n<h4>合约类型</h4>\n<p>每个合约都是一个类型</p>\n<p>合约可以显示地转换为 address 类型，从而可以使用地址类型的成员函数</p>\n<p>这段时间太忙了，先学到这吧...挖坑，后面再填</p>\n",
            "url": "https://clark-cui.top/posts/智能合约开发2.html",
            "title": "智能合约开发2",
            "summary": "智能合约",
            "date_modified": "2022-05-09T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>代码地址</h2>\n<p><a href=\"https://github.com/xilibi2003/contract-training-code\">dlsq</a></p>\n<h2>以太坊客户端</h2>\n<h3>EVM</h3>\n<p>智能合约的运行环境，是一个虚拟机</p>\n<h3>以太坊客户端</h3>\n<ol>\n<li>定义：也就是 EVM 的载体，也就是区块链网络中的节点的程序，只要符合网络规范，任何语言都可以实现客户端</li>\n<li>常见的客户端：Geth(Go 实现)、OpenEthereum(Rust 实现)，通过 RPC 提供服务</li>\n</ol>\n<h2>账户</h2>\n<p>本质都是一个 20 个字节表示的地址</p>\n<ol>\n<li>\n<p>外部账户（EOA）：由私钥控制（比如用户的地址）</p>\n</li>\n<li>\n<p>合约账户：代码控制（比如合约代码的部署地址）</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：交易只能从外部账号发出，合约只能被动执行。合约之间的交互称为消息，所有的 gas 都由外部账号支付</p>\n</blockquote>\n<h2>Gas</h2>\n<p>GAS 是一个工作量单位，复杂度越大，所需 gas 越多。费用=gas 数量*gas 单价（以太币计价 gwei）</p>\n<h3>单位</h3>\n<ul>\n<li>最小单位：Wei</li>\n<li>10^9 Wei = 1 Gwei</li>\n<li>10^12 Wei = 1 Szabo</li>\n<li>10^15 Wei = 1 Finney</li>\n<li>10^18 Wei = 1 Ether</li>\n</ul>\n<h2>网络</h2>\n<ol>\n<li><a href=\"https://cn.etherscan.com/\">主网（价值网络）</a></li>\n<li><a href=\"https://goerli.etherscan.io/\">测试网</a></li>\n<li>开发模拟网（本地环境，一般就是借助工具起虚拟机）</li>\n</ol>\n<h2>合约的编译、部署、测试</h2>\n<h3>1. Remix</h3>\n<p><a href=\"https://remix.ethereum.org/\">链接</a></p>\n<p>在contracts里添加Counter.sol</p>\n<pre><code class=\"language-solidity\">// SPDX-License-Identifier:  MIT\npragma solidity ^0.8.0;\n\ncontract Counter{\n    uint public counter;\n    constructor(){\n        counter = 0;\n\n    }\n    function count() public{\n        counter+=1;\n    }\n}\n</code></pre>\n<p>编辑器左侧面板有文件夹区域、搜索区域、编译区域、部署区域。</p>\n<p>编译区域可选编译器版本。</p>\n<p>部署区域可选部署链，成功后会显示部署地址。部署合约也是一笔交易，需要在钱包确认，也需要gas费。部署成功后会显示交互面板，橙色是触发交易，蓝色仅读取。点击橙色触发交易，需要钱包确认，需要gas费。点击蓝色读就不需要。</p>\n<p>实际操作：environment 选择 injected web3，这里连接 metamusk 钱包，钱包啥网络，就是啥网络。推荐用 goerli（eth 测试网）,去<a href=\"https://goerlifaucet.com/\">goerli faucet</a>申请一点测试币即可。部署前会连接钱包，然后就是用账号部署上去,部署完后可以去<a href=\"https://goerli.etherscan.io/\">测试链查状态</a>。</p>\n<p>部署成功后，点两次橙色触发交易，再点蓝色可以读到此时counter值的状态，控制台打印：</p>\n<pre><code class=\"language-shell\">{\n\t&quot;0&quot;: &quot;uint256: 2&quot;\n}\n</code></pre>\n<blockquote>\n<p>注意 remix 中的 environment 如果是默认的，那就是虚拟网络，在区块链浏览器是查不到的，而且不需要钱包验证，也不需要gas费</p>\n</blockquote>\n<h3>2. Truffle</h3>\n<p>Truffle:编译、部署、测试合约的一整套开发工具</p>\n<p>ganache是开发区块链，提供本地模拟的链上环境</p>\n<p><a href=\"https://trufflesuite.com/docs/truffle/\">官方文档</a></p>\n<p><a href=\"https://learnblockchain.cn/docs/truffle/\">中文文档</a></p>\n<p><a href=\"https://github.com/clark-cui/truffle-demo\">我的代码</a></p>\n<pre><code class=\"language-shell\">Truffle 安装  npm install -g truffle\n创建工程 truffle init或者truffle unbox metacoin(我用的第二个，相当于使用metacoin这个模版，注意需要手动mkdir一个folder，再在里面执行创建，注意配置proxy)\n</code></pre>\n<p>truffle工程包含</p>\n<ul>\n<li>contracts:智能合约目录</li>\n<li>migrations:迁移文件，用来指示如何部署智能合约</li>\n<li>test:智能合约测试用例文件夹</li>\n<li>truffle-config.js:配置文件，配置truffle连接的网络及编译选项</li>\n<li>build:编译结果目录</li>\n</ul>\n<p>改造下folder</p>\n<ol>\n<li>\n<p>删除contracts、migrations、test下的文件</p>\n</li>\n<li>\n<p>contracts里添加Counter.sol</p>\n<pre><code class=\"language-solidity\">// SPDX-License-Identifier:  MIT\npragma solidity ^0.8.0;\n\ncontract Counter{\n    uint public counter;\n    constructor(){\n        counter = 0;\n\n    }\n    function count() public{\n        counter+=1;\n    }\n}\n</code></pre>\n</li>\n</ol>\n<h4>合约编译</h4>\n<pre><code class=\"language-shell\">//使用命令\ntruffle compile\n</code></pre>\n<p>在那之前需要配置truffle-config.js，不配置就是默认的0.5.16版本</p>\n<pre><code class=\"language-js\">module.exports={\n  compilers:{\n    solc:{\n      version:&quot;0.8.9&quot;\n    }\n  }\n}\n</code></pre>\n<p>编译完成会输出在build目录,同时也会在命令行输出编译使用的编译器</p>\n<pre><code class=\"language-shell\">&gt; Compiled successfully using:\n   - solc: 0.8.9+commit.e5eed63a.Emscripten.clang\n</code></pre>\n<p>编译结果是json（与合约一一对应），里面abi是和前端交互的，bytecode就是最后部署在链上的东西</p>\n<h4>接下来是合约的部署</h4>\n<pre><code class=\"language-shell\">//使用命令\ntruffle migrate\ntruffle migrate --network networkname //可以在后面加network参数和network名字，部署到指定network\n</code></pre>\n<p>在那之前，需要先写好配置文件</p>\n<ol>\n<li>\n<p>编写部署脚本</p>\n<p>migrations里添加1_counter.js</p>\n<pre><code class=\"language-js\">const Counter = artifacts.require(&quot;Counter&quot;);\n\nmodule.exports = function (deployer) {\n  deployer.deploy(Counter);\n};\n</code></pre>\n</li>\n<li>\n<p>部署到本地节点（我没有搞）</p>\n<ol>\n<li>\n<p>先启动一个服务模拟链上环境<code>ganache-cli -p 7545</code>(ganache是开发区块链，提供本地模拟的链上环境)</p>\n</li>\n<li>\n<p>然后添加dev的network</p>\n<pre><code class=\"language-js\">//truffle-config.js development网络配置\n\nmodule.exports={\n  networks:{\n    development:{\n      host:&quot;127.0.0.1&quot;,\n      port:7545,\n   \t\tnetwork_id:&quot;*&quot;\n    }\n  }\n}\n</code></pre>\n</li>\n<li>\n<p><code>truffle migrate — network development</code>部署，本地部署，不需要验证和gas费</p>\n</li>\n</ol>\n</li>\n<li>\n<p>部署到链上</p>\n<ol>\n<li>\n<p>需要部署到链上的节点，所以先去<a href=\"https://infura.io/\">infura.io</a>创建一个project，然后copy project id（选择endpoints是goerli）</p>\n</li>\n<li>\n<p>当前目录新建两个隐藏文件，.api_key和.mnemonic，.gitignore要添加这两项，分别存储上一步的id和你的钱包账户助记词（主要为了防止外泄）</p>\n</li>\n<li>\n<p>初始化npm ，添加truffle-hdwallet-provider包</p>\n<pre><code class=\"language-shell\">npm init\nnpm i truffle-hdwallet-provider -s\n.gitignore 添加node_modules\n</code></pre>\n</li>\n<li>\n<p>config.js里的network里添加新的network goerli</p>\n<pre><code class=\"language-js\">const HDWalletProvider = require(&quot;truffle-hdwallet-provider&quot;);\n\nconst fs = require('fs');\nconst api_key = fs.readFileSync('.api_key').toString().trim();\nconst mnemonic = fs.readFileSync('.mnemonic').toString().trim();\nmodule.exports = {\n  networks: {\n    goerli: {\n      provider: () =&gt; {\n        return new HDWalletProvider(mnemonic, 'https://goerli.infura.io/v3/' + api_key)\n      },\n      network_id: '5',\n      gas: 4465030,\n      gasPrice: 10000000000,\n    },\n  }\n};\n</code></pre>\n</li>\n<li>\n<p>执行<code>truffle migrate — network goerli</code>部署到goerli，这里会消耗gas费，但没有metamusk弹窗确认的过程，因为我输入了助记词，他直接在钱包扣款了</p>\n<pre><code class=\"language-shell\">//命令行输出\nCompiling your contracts...\n===========================\n&gt; Everything is up to date, there is nothing to compile.\n\n\nMigrations dry-run (simulation)\n===============================\n&gt; Network name:    'goerli-fork'\n&gt; Network id:      5\n&gt; Block gas limit: 30000000 (0x1c9c380)\n\n\n1_counter.js\n============\n\n   Deploying 'Counter'\n   -------------------\n   &gt; block number:        6818292\n   &gt; block timestamp:     1651505825\n   &gt; account:             0x736D76f4C2d4b4CCced0CCA92d3dF0F0e456F35D\n   &gt; balance:             0.04813429249775099\n   &gt; gas used:            135269 (0x21065)\n   &gt; gas price:           10 gwei\n   &gt; value sent:          0 ETH\n   &gt; total cost:          0.00135269 ETH\n\n   -------------------------------------\n   &gt; Total cost:          0.00135269 ETH\n\nSummary\n=======\n&gt; Total deployments:   1\n&gt; Final cost:          0.00135269 ETH\n\n\n\n\nStarting migrations...\n======================\n&gt; Network name:    'goerli'\n&gt; Network id:      5\n&gt; Block gas limit: 29970705 (0x1c95111)\n\n\n1_counter.js\n============\n\n   Deploying 'Counter'\n   -------------------\n   &gt; transaction hash:    0x376710e125c35233b468bd232444acc2239c38e837aeecf9ef9de6762715eca8\n   &gt; Blocks: 0            Seconds: 5\n   &gt; contract address:    0xAc8dC14e7aC85556Bcc22c052FbB5Bc05D4E77D8\n   &gt; block number:        6818298\n   &gt; block timestamp:     1651505843\n   &gt; account:             0x736D76f4C2d4b4CCced0CCA92d3dF0F0e456F35D\n   &gt; balance:             0.04813429249775099\n   &gt; gas used:            135269 (0x21065)\n   &gt; gas price:           10 gwei\n   &gt; value sent:          0 ETH\n   &gt; total cost:          0.00135269 ETH\n\n   &gt; Saving artifacts\n   -------------------------------------\n   &gt; Total cost:          0.00135269 ETH\n\nSummary\n=======\n&gt; Total deployments:   1\n&gt; Final cost:          0.00135269 ETH\n\n\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<h4>补充内容</h4>\n<ol>\n<li>\n<p>Truffle console使用（可以直接在控制台调用合约）</p>\n<p>先把合约部署到development</p>\n<p><code>truffle console --network development</code>开启调用模式</p>\n</li>\n<li>\n<p><a href=\"http://truffle-min.sh\">truffle-min.sh</a>(压缩artifacts文件)</p>\n<p>我们compile后，是会在build里输出一个json，但是这个json很大，所以可以借助这个脚本来对这个json进行压缩，可以从几千行压缩到几十行，然后我们后续的开发有引用这个json的需求的时候，就可以引入这个压缩的json</p>\n</li>\n</ol>\n<h3>3. Hardhat</h3>\n<p>Hardhat:编译、部署、测试和调试以太坊应用的开发环境，围绕task（任务）和plugins（插件）概念设计</p>\n<p>在命令行运行Hardhat时，都是在运行任务，例如：npx hardhat compile就是运行compile任务</p>\n<p>Hardhat node:开发区块链，提供本地模拟的链上环境</p>\n<p><a href=\"https://hardhat.org/getting-started/\">官方文档</a>,<a href=\"https://learnblockchain.cn/docs/hardhat/getting-started/\">中文文档</a></p>\n<p><a href=\"https://github.com/NomicFoundation/hardhat-hackathon-boilerplate\">参考代码</a></p>\n<p><a href=\"https://github.com/clark-cui/hardhat-demo\">我的代码</a></p>\n<h4>创建工程</h4>\n<pre><code class=\"language-shell\">mkdir hardhat-demo //创建一个folder\ncd hardhat-demo\nnpm init //初始化npm\nnpm i -s hardhat //当前目录下安装hardhat\nnpx hardhat //在当前目录下创建项目,可以选basic-sample(注意，这一步要开启shell proxy)\n</code></pre>\n<p>contracts里新建Counter.sol，添加一下内容</p>\n<pre><code class=\"language-solidity\">// SPDX-License-Identifier:  MIT\npragma solidity ^0.8.0;\nimport &quot;hardhat/console.sol&quot;;\n\ncontract Counter{\n    uint public counter;\n    constructor(){\n        counter = 0;\n\n    }\n    function count() public{\n        counter+=1;\n        console.log(&quot;curr counter:&quot;,counter);\n    }\n    function add(uint x) public{\n        counter=counter+x;\n    }\n}\n</code></pre>\n<h4>合约编译</h4>\n<pre><code class=\"language-js\">//先修改hardhat.config.js，设置编译器版本\nmodule.exports={\n  Solidity:&quot;0.8.9&quot;\n}\n//然后命令行输入\nnpx hardhat compile \n</code></pre>\n<h4>部署</h4>\n<ol>\n<li>\n<p>编写部署脚本</p>\n<pre><code class=\"language-js\">//scripts/deploy_counter.js\nconst hre = require(&quot;hardhat&quot;);\nasync function main() {\n  //await hre.run('compile');\n  const Counter = await hre.ethers.getContractFactory(&quot;Counter&quot;);\n  const counter = await Counter.deploy(); //deploy里的括号可以传参，具体看合约里的construtor有没有参数而定\n\n  await counter.deployed();\n  console.log(&quot;Counter deployed to:&quot;, counter.address);\n}\nmain()\n  .then(() =&gt; process.exit(0))\n  .catch((error) =&gt; {\n    console.error(error);\n    process.exit(1);\n  });\n\n</code></pre>\n<p>如果想要一次部署多个合约，比如这里有counter和greeter合约，那么可以这么写</p>\n<pre><code class=\"language-js\">//scripts/deploy.js\n\nconst { ethers } = require(&quot;hardhat&quot;);\n\nasync function main() {\n  const [deployer] = await ethers.getSigners();\n  console.log('Deploying contracts with the account: ' + deployer.address);\n\n  // Deploy Greeter\n  const Greeter = await ethers.getContractFactory(&quot;Greeter&quot;);\n  const greeter = await Greeter.deploy(&quot;Hello, Hardhat!&quot;);\n\n\n  // Deploy Counter\n  const Counter = await hre.ethers.getContractFactory(&quot;Counter&quot;);\n  const counter = await Counter.deploy();\n  \n  // console.log\n\tconsole.log(&quot;Greeter deployed to:&quot;, greeter.address);\n  console.log(&quot;Counter deployed to:&quot;, counter.address);\n\n}\n\nmain()\n    .then(() =&gt; process.exit())\n    .catch(error =&gt; {\n        console.error(error);\n        process.exit(1);\n})\n</code></pre>\n</li>\n<li>\n<p>部署到本地网络</p>\n<p>先启动一个本地网络<code>npx hardhat node</code>,然后再根据端口值来修改hardhat.config.js，增加以下内容</p>\n<pre><code class=\"language-js\">//hardhat.config.js\nmodule.exports={\n  networks:{\n    development:{\n      url:&quot;http://127.0.0.1:8545&quot;,\n      chainId:31337\n    }\n  }\n}\n</code></pre>\n<p>执行部署<code>npx hardhat run scripts/deploy_xxx.js [--network 网络]</code>，而这里的话，就是执行<code>npx hardhat run scripts/deploy_counter.js --network development</code></p>\n</li>\n<li>\n<p>部署到链上</p>\n<p>需要部署到链上的节点，所以先去<a href=\"https://infura.io/\">infura.io</a>创建一个project，然后copy project id（选择endpoints是goerli）</p>\n<p>本地添加.api_key和.mnemonic，.gitignore添加过滤这两项，然后修改hardhat.config.js,增加以下内容</p>\n<pre><code class=\"language-js\">//hardhat.config.js\nconst fs = require('fs');\nconst api_key = fs.readFileSync('.api_key').toString().trim();\nconst mnemonic = fs.readFileSync('.mnemonic').toString().trim();\nmodule.exports={\n  networks:{\n    goerli:{\n      url:`https://goerli.infura.io/v3/${api_key}`,\n      accounts:{\n        mnemonic:mnemonic,\n      }\n    }\n  }\n}\n</code></pre>\n</li>\n</ol>\n<p>​\t\t执行部署<code>npx hardhat run scripts/deploy.js --network goerli</code></p>\n<h4>测试</h4>\n<pre><code class=\"language-js\">const {expect} = require(&quot;chai&quot;);\nconst {ethers} = require(&quot;hardhat&quot;);\n\ndescribe(&quot;Counter&quot;, function () {\n  it(&quot;counter should be 0 when init , be added 1 after count be called, be added x after add be called with x&quot;, async function () {\n    const Counter = await ethers.getContractFactory(&quot;Counter&quot;);\n    const counterInstance = await Counter.deploy();\n    await counterInstance.deployed();\n    expect(await counterInstance.counter()).to.equal(0);\n\n    const setCountTx = await counterInstance.count();\n\n    // wait until the transaction is mined\n    await setCountTx.wait();\n\n    expect(await counterInstance.counter()).to.equal(1);\n\n    const addCountTx = await counterInstance.add(10);\n    await addCountTx.wait();\n    expect(await counterInstance.counter()).to.equal(11);\n  });\n});\n</code></pre>\n<p><code>npx hardhat test</code>执行测试</p>\n<h4>实战</h4>\n<ol>\n<li>\n<p>调试利器：console.log</p>\n<pre><code class=\"language-solidity\">import &quot;hardhat/console.sol&quot;;\n\nconsole.log(counter);\n</code></pre>\n</li>\n<li>\n<p>灵活参数部署，利用hardhat可以在代码中引用(这里值的是合约初始化的参数，也就是constructor需要的参数，比如Greeter合约，这里可以在部署脚本里传入参数，比如deploy_greeter.js所写。也可以用nodejs的方式，在命令行传入参数,然后在部署脚本里取出来)</p>\n<ol>\n<li>\n<pre><code class=\"language-solidity\">// Counter.sol\n// SPDX-License-Identifier:  MIT\npragma solidity ^0.8.0;\nimport &quot;hardhat/console.sol&quot;;\n\ncontract Counter{\n    uint public counter;\n    constructor(uint _counter){\n        counter = _counter;\n\n    }\n    function count() public{\n        counter+=1;\n        console.log(&quot;curr counter:&quot;,counter);\n    }\n    function add(uint x) public{\n        counter=counter+x;\n    }\n}\n\n// test_counter.js\nconst {expect} = require(&quot;chai&quot;);\nconst {ethers} = require(&quot;hardhat&quot;);\n\ndescribe(&quot;Counter&quot;, function () {\n  it(&quot;counter should be 0 when init , be added 1 after count be called, be added x after add be called with x&quot;, async function () {\n    const Counter = await ethers.getContractFactory(&quot;Counter&quot;);\n    const counterInstance = await Counter.deploy(0);\n    await counterInstance.deployed();\n    expect(await counterInstance.counter()).to.equal(0);\n\n    const setCountTx = await counterInstance.count();\n\n    // wait until the transaction is mined\n    await setCountTx.wait();\n\n    expect(await counterInstance.counter()).to.equal(1);\n\n    const addCountTx = await counterInstance.add(10);\n    await addCountTx.wait();\n    expect(await counterInstance.counter()).to.equal(11);\n  });\n});\n\n//deploy_counter.js\n//其余相同，只需改下面这一句\n const counter = await Counter.deploy(0);\n\n</code></pre>\n</li>\n<li>\n<p>设置deploy脚本</p>\n<pre><code class=\"language-js\">const {ethers} = require(&quot;hardhat&quot;);\n\nconst params=process.argv;\nconst value=params[2];\nconsole.log(&quot;Counter deploy with value:&quot;,value);\nasync function main() {\n  //await hre.run('compile');\n  const Counter = await ethers.getContractFactory(&quot;Counter&quot;);\n  const counter = await Counter.deploy(value);\n\n  await counter.deployed();\n  console.log(&quot;Counter deployed to:&quot;, counter.address);\n\n}\nmain()\n  .then(() =&gt; process.exit(0))\n  .catch((error) =&gt; {\n    console.error(error);\n    process.exit(1);\n  });\n\n\n</code></pre>\n</li>\n<li>\n<p>执行node脚本,并传递参数</p>\n<p>需要两个命令，可以在命令行依次执行，<a href=\"http://xn--4gqvdzgque2iqseq47a.sh\">也可以写成一个.sh</a>，<code>sh ./deploy_by_param.sh   </code>执行这个.sh即可</p>\n<pre><code class=\"language-shell\">// ./deploy_by_param.sh\nexport HARDHAT_NETWORK='development' //设置network的值是development；这就是node执行hardhat脚本附着hardhat参数的方式+\nnode scripts/deploy_by_param.js 10 //在这里传入初始化参数是10\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>代码扁平：<code>npx hardhat flatten xxx.sol &gt; xxx.sol</code></p>\n<p>本质的意义是，当一个合约的里面有import引用的时候，可以用这个命令把引用的代码和本身的代码放在一起，方便看，这里的话就是<code>npx hardhat flatten contracts/Counter.sol &gt;&gt;Counter.sol</code></p>\n</li>\n<li>\n<p>代码验证</p>\n<p>当合约部署在链上后，可以通过这个命令来对代码进行验证</p>\n<pre><code class=\"language-shell\">1.先安装 npm i hardhat-etherscan --dev\n2.hardhat.config.js里添加require(&quot;@nomiclabs/hardhat-etherscan&quot;)\n3.添加scankey,const scankey=`${scanKey}`; //因为调用etherscan的api，所以需要去他那里申请一个key, https://etherscan.io/,这个key最好也用隐藏文件，不要暴露出去\n4.在配置里，networks的下面，添加同级项 etherscan:{apiKey:scankey}\n5.命令行执行npx hardhat verify address --network xxx // address是合约的部署地址，xxx是要验证的网络\n</code></pre>\n</li>\n<li>\n<p>ABI导出</p>\n<p>当合约部署后，需要导出ABI供前端调用，默认的deploy就会导出一个总的json里面包括abi，不过比较大而已，这里是仅导出abi的json</p>\n<pre><code class=\"language-shell\">1.先安装 npm i hardhat-abi-exporter --dev\n2.hardhat.config.js里添加require(&quot;hardhat-abi-exporter&quot;)\n3.hardhat.config.js里配置下导出,新建./abi目录来存放\n  abiExporter: {\n    path: './abi',\n    runOnCompile: true,\n    clear: true,\n    flat: true,\n    spacing: 2,\n    pretty: false,\n  }\n4.npx hardhat export-abi\n</code></pre>\n</li>\n<li>\n<p>自定义Task</p>\n<p>在hardhat.config.js里可以写task,然后通过<code>npx hardhat taskName</code>完成一些想要做的事，也可以在task文件夹里写，然后在hardhat.config.js用require引入</p>\n<pre><code class=\"language-js\">task(&quot;accounts&quot;,&quot;Prints the list of accounts&quot;,async(taskArgs,hre)=&gt;{\n  const accounts =await hre.ethers.getSigners();\n  for(const account of accounts){\n    console.log(account.address)\n  }\n})\n\n//命令行 npx hardhat accounts执行\n</code></pre>\n</li>\n<li>\n<p>书写脚本去调用合约，实现前端与合约的交互</p>\n<ol>\n<li>\n<p>前端想要调用合约，那就得知道合约的地址和abi，之前有用npm处理了abi的单独导出，但是并没有处理合约的地址，所以这里我们改造下deploy脚本，让它自动保存地址和abi到一个data的目录下</p>\n<pre><code class=\"language-js\">// scripts/deploy_counter.js\nconst hre = require(&quot;hardhat&quot;);\nasync function main() {\n  //await hre.run('compile');\n  const Counter = await hre.ethers.getContractFactory(&quot;Counter&quot;);\n  const counter = await Counter.deploy(0);\n\n  await counter.deployed();\n  console.log(&quot;Counter deployed to:&quot;, counter.address);\n  saveFrontendFiles(counter);\n}\n\nfunction saveFrontendFiles(counter) {\n  const fs = require(&quot;fs&quot;);\n  const contractsDir = &quot;./data&quot;;\n\n  if (!fs.existsSync(contractsDir)) {\n    fs.mkdirSync(contractsDir);\n  }\n\n  fs.writeFileSync(\n    contractsDir + &quot;/contract-address.json&quot;,\n    JSON.stringify({\n      Counter: counter.address\n    }, undefined, 2)\n  );\n\n  const CounterArtifact = artifacts.readArtifactSync(&quot;Counter&quot;);\n\n  fs.writeFileSync(\n    contractsDir + &quot;/Counter.json&quot;,\n    JSON.stringify(CounterArtifact, null, 2)\n  );\n}\nmain()\n  .then(() =&gt; process.exit(0))\n  .catch((error) =&gt; {\n    console.error(error);\n    process.exit(1);\n  });\n\n//然后执行脚本 npx hardhat run scripts/deploy_counter.js --network development\n</code></pre>\n</li>\n<li>\n<p>新建action.js实现前端调用合约的逻辑</p>\n<pre><code class=\"language-js\">const {\n  ethers\n} = require(&quot;hardhat&quot;)\nconst CounterArtifact = require(&quot;../data/Counter.json&quot;)\nconst contractAddress = require(&quot;../data/contract-address.json&quot;);\n\n(async () =&gt; {\n  // init\n  const provider = new ethers.providers.JsonRpcProvider('http://127.0.0.1:8545/');\n\n  // Then, we initialize the contract using that provider and the token's\n  // artifact. You can do this same thing with your contracts.\n  const counter = new ethers.Contract(\n    contractAddress.Counter,\n    CounterArtifact.abi,\n    provider.getSigner(0)\n  );\n\n  console.log(&quot;counter值是：&quot;,await counter.counter())\n\n  await counter.count();\n  console.log(&quot;counter值是：&quot;,await counter.counter())\n\n})()\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n",
            "url": "https://clark-cui.top/posts/智能合约开发.html",
            "title": "智能合约开发",
            "summary": "智能合约",
            "date_modified": "2022-05-06T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>什么是 DeFi</h2>\n<p>DeFi 是 Decentralized Finance 的缩写，也就是去中心化金融，大概意思就是把一些传统的金融产品复制到了区块链上，比如给 makerDao 这个 DApp,用户可以用它通过质押自己的数字资产，然后获得收益，整个流程通过智能合约控制。<br>\n但是也不仅仅是传统金融，还要打通区块链和现实世界，所以就有了合成资产（Synthetic Assets）和语言机(Oracle)。</p>\n<h3>合成资产</h3>\n<p>简单来讲，就是抵押一种现实资产从而获得另一种在链上的资产。比如美元是现实资产，稳定币 USDT 就是泰达公司通过抵押美元而得到的合成资产。通过这个工具，我们可以把现实资产映射到链上。</p>\n<h3>预言机</h3>\n<p>它是把现实世界的数据传输到区块链上的通道。许多 DeFi 智能合约的运转需要现实数据输入。比如上面提到 makerDao 就需要获取以太坊的实时价格。有了预言机，DeFi 才能和现实世界互通。</p>\n<h3>DeFi 的优势与劣势</h3>\n<p>DeFi 有透明，去中心化，能 24h 交易，没有中间商赚差价的优势。但是，因为 DeFi 的透明机制，智能合约的代码是开源的，也就更容易被黑客攻击。</p>\n<h2>EVM 是什么</h2>\n<p>是 Ethereum Virtual Machine 的缩写，翻译过来就是以太坊虚拟机，是一种虚拟机，用来运行智能合约代码。以太坊上有许多的智能合约，在满足条件后就会自动执行。之所以需要虚拟机，是因为节点的环境不同，为了保证智能合约运行结果的一致，所以需要一个虚拟机，统一合约代码的运行环境。okc 上也上了 evm，所以 eth 上的智能合约都能轻松地在 okc 上部署</p>\n<h2>NFT 是什么</h2>\n<p>是 Non-Fungible Tokens 的缩写，翻译为非同质化通证。非同质化对应同质化，比特币就是同质化通证，比如，我的一枚比特币与小张的一枚比特币没有任何区别，同时，我也能把自己的一枚比特币分割成 10 份，每份 0.1 枚。而非同质化通证却不是，每个 NFT 都有一个独特且唯一的标识，不可复制，最小单位是 1，不可分割。</p>\n<h3>如何使用 NFT</h3>\n<p>把图片上传到 NFT 平台，填写资产说明，并连接钱包，智能合约会生成一份代表这个图片所有权的 NFT 通证，并发送到你的钱包地址，然后就可以在这个平台把这个 NFT 上架拍卖。之后的每一次转卖，作者都会获得一定比例的分成。</p>\n<h3>NFT 的应用</h3>\n<p>不只是图片，各种数字产品都可以。还可以把一份收藏品分成很多份，每一份生成 1 个 NFT，这样就可以大大降低准入门槛。</p>\n<h2>DeFi 是如何帮你借贷的</h2>\n<p>DeFi 借贷，是将借贷协议用智能合约自动执行，通过协议来匹配借方和贷方，在质押确认后及时划转资产。</p>\n<ol>\n<li>\n<p>最火热的流动池模式<br>\nDeFi 借贷系统相当一一个公开透明，自动运营的资金池，资金池中的水是加密资产，用户存入、归还加密资产时就相当于有水流汇入，用户取出存款或借款时，就有水流出。<br>\n你存入加密资产后，会有一个 aToken，就跟存折一样，当你决定取款时，向 DeFi 系统归还取款凭证，就可以收回原来存入的资产并获得收益。另外，你还可以把这个存款凭证 aToken 放在二级市场交易。<br>\n在借款时，要向 DeFi 系统抵押，并且要超额抵押，假设最低抵押率是 150%，那么想要借 100 元就要抵押 150 元的存款凭证，这是为了确保资金池不会因为借款而枯竭。另外，当你以加密资产 A 作为抵押，借出加密资产 B，当币价波动，A 的价格下降或者 B 的价格上升时，抵押率就会下降，为了保证借出去的加密资产 B 始终有足额担保，DeFi 系统设置了清算过程，它设定了一个清算值（也是百分比），当抵押率低于这个清算值时，DeFi 系统会触发清算，并将你抵押的部分加密资产 A 冻结拍卖，这个时候其他人可以用折扣价，用加密资产 B 买下这部分抵押物，相当于系统帮你做了偿还的操作，与此同时，系统会对你收取罚金作为处罚。</p>\n</li>\n<li>\n<p>闪电贷<br>\n可以在不卖出加密资产的前提下，借出我们急需的加密资产。但超额质押的机制，限制了我们的资金利用率，所以有了无抵押贷款——闪电贷，条件是在同一区块链交易结束前进行偿还，不然这个借贷就不被承认。举个例子，你使用 1 次共享单车，视为 1 次区块链交易，在你扫码开锁时，可以向单车平台借一笔款，期间你可以随意使用这笔钱，当骑行结束关锁时，你必须向平台还款。</p>\n</li>\n</ol>\n<p>优点是过程透明简单，没有繁琐的审核，任何人都能借贷。缺点是智能合约代码开源，容易被黑客抓住漏洞进行攻击，损失无法挽回。基 eth 协议的 DeFi 借贷手续费较高，链上拥堵时有发生，降低用户体验，极端情况下会导致借款人来不及补充抵押物而遭到清算。</p>\n<h2>什么是去中心化交易所</h2>\n<p>中心化交易所（CEX）：单个买方和卖方难以匹配，所以需要一个撮合平台，以挂单的形式，平台根据价格和时间来均衡排序，帮助买卖双方的匹配</p>\n<p>去中心化交易所（DEX）：Decentralized Exchange 的缩写。有人探索把交易所放在链上，于是诞生了 Dex。通过智能合约进行订单撮合，并进行交易结算，交易的全部流程也都会通过智能合约记录到区块链上。</p>\n<p>早期的去中心化交易所，会把买卖双方的挂单存储在区块链上的订单簿上，并在区块链上进行撮合和交易结算。卖方填写订单请求，并用私钥签名后提交到区块链上锁定，买方在挂单中进行选择，确认后，由智能合约对这两者的交易需求进行匹配，交易成功后在链上进行结算。也就是说，交易时，挂单、交易结算、提现等操作都是由智能合约在链上完成的，也就意味着交易时需要时间等待的步骤（在区块链上被矿工确认），而且需要给矿工支付 Gas 费，最后导致又慢又贵，体验很差。</p>\n<p>第二代去中心化交易所，开始把为买卖双方匹配最佳订单的撮合过程放在链下，只把最后的撮合结果提交到区块链上，由智能合约完成最后的结算。这种链下订单簿的模式，减少了链上确认的频次，但依然不能满足即时交易的需求，也在一定程度上牺牲了去中心化的优势。</p>\n<p>新的去中心化交易所，引入了 AMM（Automated market maker）机制，也就是自动做市商模式，它直接根据算法，计算出两个或几个资产之间的汇率，买卖双方不再进行订单匹配，而是通过智能合约和流动性资金池进行交易。举个例子，一个 AMM 菜市场，有一个台子，左边是一堆大米，右边是一堆钱，中间是一个机器人。卖大米的人来了，他只要把自己的大米放在左边，机器人根据函数计算出价格，并告诉他可以从右边拿走多少钱。买大米的人来了，他只要把钱放在右边，机器人会根据函数计算结果，告诉他可以从左边拿走多少大米。这样就实现了不用挂单等待的即时交易。Uniswap 就是这么干的。</p>\n<p>去中心化交易所，不需要开户和身份核验就能使用，也不用将资产托管给交易所，资产安全更有保障。但是缺点是链上交易受到区块链网络性能的影响，AMM 机制解决了去中心化交易所链上交易不足，流动性差的问题，但也带来了滑点、无偿损失的问题。</p>\n<h3>关于 AMM 自动化做市商的一切</h3>\n<p>它根据算法，计算出几个资产之间的汇率，用户根据汇率来兑换资产， 流动性资金池是其中的关键。你只需要把自己的加密资产按比例投入流动性池中，就可以为他提供流动性。流动性资金池越大，大家的交易就越方便。<br>\n为了激励大家提供流动性，有些项目方会给流动性提供者分发项目的治理代币，这就是流动性挖矿。你可以参与流动性挖矿赚取收益，但这并不是稳赚不赔的生意，你还要小心滑点和无偿损失。<br>\nAMM 模式的交易所，汇率计算是其中的要点，它的原理是一个函数，以 uniswap 为例，它使用的函数是 x *y=k,x 和 y 分表代表了不同资产在交易所中的数量，k 是约定好的常数。初始阶段，uniswap 两个兑换池的资金价值相等，举个例子，假设苹果和梨都是 1 元，初始有 10 个苹果，10 个梨，所以 k=x *y=10 *10=100,对于任何交易，uniswap 都要保证池中的苹果 *香蕉=100。所以当你卖 1 个苹果给 uniswap,池子里就有了 11 个苹果，为了保证 k=100，所以池子里香蕉的数量就是 9.09，那么相当于你卖出 1 个苹果，得到了 0.91 个香蕉。以前，1 个苹果能换 1 个香蕉，现在 1 个苹果却只换到了 0.91 个香蕉，这少拿走的 0.09 个香蕉，就是滑点导致的。这也是这个公式的缺点，当一个币对池，其中一个币被卖入的越多，那这个币就越便宜，同理，被买走的越多就越贵。滑点与交易池的大小有关，比如刚才的例子，如果是 100 个苹果，100 个香蕉，那么拿 1 个苹果就能换 0.99 个香蕉，滑点是 0.01。<br>\n然而市场上币价波动性大，假如市场上苹果价格不断上涨，然而这个流动性池中苹果的价格还是相对比较便宜的，所以就会有人不断地在流动性池中充入香蕉换取苹果来套利。<br>\n假设还是之前那个 10 *10 的模型，苹果的市场价格涨到了 5 元，香蕉仍然是 1 元。所以就有人在这个过程中不断用香蕉换苹果套利，然后池子里就剩下 5 个苹果，20 个香蕉，k 还是 100。此时池子里的价值是 5 *5+20 *1=45 元。假设池子的流动性都是你添加的，相当于你参加了流动性挖矿，那么你的资产价值就是 45 元。但如果你不参与流动性挖矿，你原来的 10 个苹果，10 个香蕉都还在，那么此时价值就是 10 *5+10 *1=60 元，参与流动性挖矿反倒赚的少了，这 15 美元的差价就是无常损失。uniswap 的无常损失情况可以通过曲线图快速知晓（losses to liquidity providers due to price variation）,展示了价格变化多少时，无偿损失会有多少。</p>\n<p>不同的去中心化交易所，会选择不同的函数来减少滑点和无偿损失。</p>\n",
            "url": "https://clark-cui.top/posts/DeFi科普.html",
            "title": "DeFi科普",
            "summary": "DeFi基础知识",
            "date_modified": "2022-05-01T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>什么是区块链</h2>\n<p>由链连接的一个个区块构成，特点是去中心化。</p>\n<p>是分布式账本，有一个大帐本，还有无数小账本，人人可以参与记账，共同维护，解决了信任问题，因为只要有任何一方有篡改，那么就会和别的账本不一致，这样就可以保证数据的安全。</p>\n<p>挖矿：指区块链网络中的一种奖励行为，为了激励大家参与数据维护，会发放一定量的比特币作为奖励。</p>\n<p>挖矿原理：每隔一段时间，就需要矿工把没有确认的交易收集起来，进行处理，谁能最先处理好数据，并进行广播，得到大部分的确认没问题，就会得到奖励。参与挖矿的人越多，参与数据确认的人也就越多，我们的数据也就越安全。</p>\n<p>区块链的分叉：是一种区块链的升级机制。相当于现有区块链中，某一个区块开始，他的下一个区块有 2 个，相当于从这里开始，有两条路径可选，像树枝一样。分为硬分叉和软分叉，逐渐过渡的是软分叉，隔离开的是硬分叉。</p>\n<p>分类：共有链，私有链，联盟链。对任何人开发的是共有链，属于个人或者公司的是私有链，属于几个公司组成的联盟的是联盟链。共有链开放程度最大，去中心化最大，但是效率最低。私有链开放程度最低，去中心化最低，效率最高。</p>\n<p>区块链的核心技术：分布式存储，共识机制，智能合约，密码学。分布式存储就是每个人那里都有一份小账本；共识机制就是决定谁获得数据的记账权的机制，也就是该用哪个矿工记录的数据；智能合约就像合同，是一种大家的约定，部署在链上，起到数据执行的作用；密码学起到数据安全和数据证明的作用。</p>\n<h2>区块链中的密码学：</h2>\n<p>区块链中主要用到的两个算法是哈希算法和非对称加密。</p>\n<ol>\n<li>\n<p>哈希算法：是一个函数，用于将任意长度的二进制数据转换为固定长度的二进制数据，这个固定长度的二进制数据就是哈希值。<br>\n它具有三个特点：<br>\n一是哈希值是不可逆的：由一个哈希值是无法反推算出它的原始输入值的，所以哈希加密能保障原始数据的安全。<br>\n二是哈希值是不可变的：对于输入值的改变，哪怕只是一小点的变化，哈希值的变化也会非常大。所以区块链中的每一个区块，都会以上一个区块的哈希值作为标识，除非有人能破解整条链上的哈希值，否则数据一旦被记录，就不会被篡改，因为只要改了数据，他的哈希值就变了，那么这个区块就会从链上断开。<br>\n三是哈希值是抗碰撞的：也就是两个不同的输入，是不会得到相同的哈希值的。区块链中的交易和地址就是用哈希生成的，这保证了交易和地址的唯一性。</p>\n</li>\n<li>\n<p>非对称加密：是一种加密方法。比如钥匙和锁，用同一把钥匙去加密和解密，那就是对称加密，钥匙也就是密钥。而非对称加密有两个密钥，一个私钥，一个公钥，公钥是公开的，私钥是私有的，公钥可以解开私钥加密的内容，私钥也可以解开公钥加密的内容。在区块链中，它并不是用来加密数据的，而是用来解决身份验证问题的。</p>\n</li>\n</ol>\n<h2>区块链中的分布式账本</h2>\n<p>是一种数据存储的技术，是一个去中心化的分布式数据库。分布式数据库的诞生，主要是为了解决单一数据库的种种问题，比如某一数据库瘫痪了，那么还能有别的数据库顶替。没有一个中心，大家都能访问就是去中心化。分布式账本的作用不只是保障了数据的多重备份，同时还赋予了去中心化的属性，防止巨头的数据垄断。</p>\n<h2>拜占庭将军问题</h2>\n<p>本质上是区块链中，如果某一节点发送错误信息，或者节点中产生了分歧，该怎么办的问题。<br>\n具体背景是：拜占庭帝国想要攻打一个国家，他派出了多支军队进行围攻，但敌方也很强大，军队必须在同一个时间一起发动进攻才能胜利。现在的问题是，军队分散在敌国的四周，只能依靠通信兵骑马互相通信来确定进攻时间。但是通信兵可能在送信过程中被敌方击杀，而且这几支军队中有叛徒存在，可能会向别的军队传达虚假指令。这种情况下，怎么才能获取胜利？<br>\n推广到区块链，相当于区块链中，可能有节点因为网络问题，发不了信息，或者有节点恶心发送错误信息。<br>\n拜占庭容错：是一种数学观点证明，简单来说就是，信息的伪造和错误并不重要，只要诚实的将军数量大于总数的三分之二，整个系统也可以达成一致。<br>\n基于拜占庭容错的观点，诞生了很多解决拜占庭将军问题的方案，比如共识机制。</p>\n<h2>共识机制</h2>\n<p>就是一套每个节点都要遵守的规则，规定了每个节点如何记账，节点之间如何交换信息。<br>\n目前主流的有两种，一种是 pow 共识机制，一种是 pos 共识机制。</p>\n<ol>\n<li>\n<p>pow 共识机制：也就是 proof of work 工作量证明，最早是用来解决垃圾邮件问题，目前是区块链中主流的共识机制。主要是通过竞争记账的方式来解决各个节点间的一致性问题。原理是：每一个节点都能参与数据处理，也就是打包区块，每一个区块都要依靠自己的计算能力与他人竞争，争夺记账的权利，也就是每隔 10 分钟，参与的节点会进行 1 次算力竞赛，也就是不断寻找一个随机数 Nonce，谁先找到满足异地过条件的 Nonce 值，且通知全网，获得大部分认可，就会获得记账的权利，它所打包的区块会连接到区块链的链上，同时，它处理的数据，也会被别的节点的账本记录，然后他会得到一定的比特币作为奖励。通过算力竞赛的方式，提高了攻击者的成本，理论上除非它能掌握全网 51%以上的算力，否则整个网络的任何东西，都是无法被篡改的。它的缺点就是，浪费大量的计算资源，性能效率低下等等</p>\n</li>\n<li>\n<p>pos 共识机制：也即是 proof of stake 权益证明。简单来说，就是谁拥有的权益多，谁说了算。它是在 pow 的基础上做了改进，pow 允许所有人都可以成为节点，参与算力竞赛，抉出记账权。而 pos 则提高了门槛，虽然所有人都可以成为节点，但是只有拥有足够的权益（比如抵押一定数量的代币）的节点才能成为验证节点，每隔一段时间，系统会从验证节点中挑选出节点来给他记账权，每隔一段时间会重新选择，系统保证选择的随机性，记账完成后会得到奖励。它解决了资源浪费的问题，但它的缺点是，容易造成强者恒强的局面，理论上谁能掌握全网 51%的代币，谁就能掌握整个网络，所以他的去中心化更弱一些。</p>\n</li>\n</ol>\n<h2>智能合约</h2>\n<p>也就是一种约定，当满足一定条件后，程序自动执行的技术。人与机构的智能合约还是挺普遍了，比如无人售货机。但是人和人之间的智能合约却还没有普及，当没有一个中心化的机构来做担保，那交易双方如何保证合约的执行？这就是智能合约解决的问题。依托于区块链，它能被搭建在应用层中，记录在区块上，保证了不可篡改，和透明公开，同时当满足条件时，智能合约也会自动执行。</p>\n<h2>双花问题</h2>\n<p>意思是一笔钱被花了两次，分两个子问题，一种是因为同步延迟的问题，导致一笔钱被重复花了几次；另一种是一笔钱只使用了 1 次，但是通过黑客攻击或者造假的方式，把这笔钱又复制了 1 份，再次使用。传统的中心化交易，由中心化机构解决这个问题，但是区块链中，因为交易需要广播有延时，所以更容易发生双花问题。<br>\n共识机制中引入了时间戳和 UTXO 模型来解决问题</p>\n<h4>UTXO 账户模型</h4>\n<p>中文意思是：未花费交易输出。它不只是记录交易结果，而是把交易过程都记录下来，本质是一种流水记账。可以由记录值反推出整条交易链路。通过可追溯的链路，解决了第一种双花问题。</p>\n<h3>时间戳</h3>\n<p>时间戳就是数据的生产日期，用来证明数据在某个时间点已经存在，用来解决第二种双花问题。</p>\n<h2>侧链技术</h2>\n<p>让链和链之间产生价值交互的一种技术，简单来说，就是建立新的一条区块链，与原有的一条链产生联系，资产可以在两条链中进行转移。主要应用于弥补原来的链的不足。原来的链叫主链，新的链叫侧链。一般来说，资产只能在一条链中转移，之所以这里可以做到在两条链转移，主要是使用了双向锚定的技术。例如，当主链的一定数量的比特币要转移到侧链时，就把主链的同等数量的比特币锁定，在侧链放出同等数量的侧链代币。同理，当从侧链向主链转移时，侧链的代币锁定，主链释放同等数量的比特币。</p>\n<h2>跨链技术</h2>\n<p>跨链技术就是侧链技术的升级版，只不过从之前的 1 对 1 的关系变成了 1 对多。就是让多条链之间产生价值交互的一种技术。解决了各条区块链之间形成的孤岛问题。<br>\n实现跨链的方式：</p>\n<ol>\n<li>公证技术：提出一个公共的协议，能适用于各条链的系统，大家都以此作为统一的支付标准</li>\n<li>中继：建一条的新的链，让其他链与这条新链产生联系。相当于是需要跨链的这些链都有一条相同的侧链，大家都通过这条侧链来作为中介进行价值交互（okc 就是用的这种技术）</li>\n<li>分布式私钥控制：相当于建立一个去中心化的银行，各条链通过这个银行来进行价值交互</li>\n<li>哈希锁定（在闪电网络中讲）</li>\n</ol>\n<h2>闪电网络</h2>\n<p>2015 年提出来，用来解决比特币交易拥堵的一项技术。比特币最开始设计的时候，一个区块只有 1M 大小，只能记录上千笔交易，很快容量就不够了，造成拥堵。社区提出两个方案，一种是扩大比特币区块容量，另一种是不扩容的方案。闪电网络就属于不扩容的方案。<br>\n原理是：交易过程中，把交易的过程放在链下，在链下记录交易副本，在交易完成后，把交易的结果再拿回链上，再进行全网广播。相当于把交易的过程放到了侧链，主链只需要记录结果，解决了拥堵问题。同时，因为交易的过程是在链下进行的，只需要智能合约来执行，不需要每一步都进行全网的广播和确认，所以大大提升了处理效率。<br>\n闪电网络也能进行跨链，它要求需要跨链的两条链都支持闪电网络，两条链都将资产暂存到链下的通道中的临时账户，通过哈希锁定，让不同链的资产在兑换时能同时结算</p>\n<h2>隔离见证技术</h2>\n<p>也是一种解决区块链拥堵的方案，不同于闪电网络的链下处理方案，它是在链上进行的。之前提到的直接扩大区块容量其实比较有争议，因为区块容量扩大后，可能会导致一些节点无法完成区块验证工作，也会导致全网算力的下降。所以这是一种不修改区块容量的技术。<br>\n原理是：腾空间。一般交易记录会含有交易信息和非交易信息（比如谁的私钥签名等等），把非交易信息剥离出来，放到新的结构中，从而腾出空间来。</p>\n<h2>分片技术</h2>\n<p>为了解决区块链的效率问题和可扩展性问题而诞生的技术。背景是，区块链是一条链式结构，在这条链上需要处理很多工作（比如交易记录、智能合约、记账、数据记录、数据存储、数据安全等等），这些工作糅合在一起，影响效率。分片技术是分而治之的原理，就是把每个区块划分成一个个分片，每个分片承担不同的职责，节点也分散到各个分片上，每个分片上的节点聚焦自己的工作，大大加快效率。但这样会降低区块链的中心化程度，也降低安全性。因为原理黑客攻击的话，需要攻击全网的大部分节点才能达到效果，使用分片技术后，黑客只需要搞定这些节点中的分片就可以了。所以有一个新的机制，会生成随机数，为其他分片分配节点。因为节点是随机分配的，黑客就很难知道节点都有谁。</p>\n<h2>区块链基础技术总结</h2>\n<p>主要是四大技术：分布式账本、共识机制、密码学、智能合约，分别起到了数据的存储、数据的处理、数据的安全、数据的应用的作用，共同构成了区块链的基础框架。在这些技术的基础上，区块链仍然面临着效率问题、可扩展性问题、价值孤岛的互操作性问题，通过引入侧链、跨链、闪电网络、隔离见证、分片等技术来解决这些问题。</p>\n<h2>比特币</h2>\n<p>是一种投资商品，数字资产，数字黄金。由中本聪发明的，具有总量恒定，机制透明，不受任何控制，由机器来执行的特点。</p>\n<h3>比特币与区块链的关系</h3>\n<p>中本聪最早只是想创造一种去中心化的数字货币，也就是比特币。但是人们发现，比特币的底层机制十分优秀，于是提取出来，形成了区块链技术。比特币相当于是区块链的一种应用。也迎来了以数字货币为代表的区块链 1.0 时代。</p>\n<h2>什么是数字货币的减半</h2>\n<p>一开始中本聪在设计比特币的时候，使用的是一个总量恒定的通缩型经济模型，也就是每 10 分钟会产生一个新的区块，每个区块带来 50 个比特币。而每产生 21 万个区块之后，也就是每过 4 年之后，区块带来的比特币奖励就会减半，也就是从第 21 万零 1 个区块开始，每个区块只带来 25 个比特币奖励。依此类推，当到第 33 次减半之后，每个区块的奖励会从 0.0021 个比特币奖励直接变为 0。所以总体算下来，比特币的总量就只有 2100 万枚。这就是减半机制，大部分的数字货币都沿袭了比特币的这一机制。</p>\n<h2>莱特币</h2>\n<p>是主流币的一种，创始人是李启威，因为早期比特币网络拥堵，交易速度慢，所以他想打造一个对标比特币支付，更轻更快的数字货币，也就是莱特币，其实就是山寨比特币。早期不愠不火，后来因为勇于试验新技术，所以被当作比特币的试验田，发展不错。</p>\n<h2>以太坊</h2>\n<p>以太坊是数字货币中，除比特币之外，最有开创意义的一个项目。以太坊就是一个开源的，能让大家自由开发智能合约的区块链公共平台，就像安卓或者 windows 这类的操作系统，它能提供一套专门的脚本语言，让大家可以随意地在上面开发各种区块链式的应用程序。以太坊虽然是平台，但是他和数字货币有紧密的关系，因为以太坊中的 Gas 机制。在以太坊的工作原理中，所有用户写好的智能合约都需要通过一个叫做虚拟机的东西作为介质去执行，而这个介质会被以太坊网络中参与的矿工共同维护，进而形成一个属于以太坊的计算网络。当你想要执行智能合约时，都需要通过这个计算网络去进行处理，并且会消耗一定的网络资源，而你也需要承担一定的成本。在以太坊网络中，衡量智能合约运行成本的标准就是 Gas。在以太坊网络的设定中，Gas 就是智能合约的运行燃料，用户想要执行智能合约时，就需要向矿工购买 Gas,如果用法币的话不管是跨境转账还是汇率都比较麻烦，于是以太坊就参照比特币的模式，也搞了一套数字货币体系来解决这个问题。即可以作为激励机制，奖励矿工，又可以充当手续费。所以以太坊本身的定位虽然是区块链版的操作系统，但是它也做了属于自己的数字货币。</p>\n<h3>以太坊带来的影响</h3>\n<p>在以太坊之前，区块链只有数字货币这种用途，以太坊开创了区块链技术在别的方向的应用。以太坊在上方应用层的层面，给出了一套编程语言，让用户可以通过智能合约，自由地开发去中心化 app，在下方数据管理层面，则通过 pos 共识机制，打造了一个去中心化的数据库，让用户数据归属于用户自己。以太坊开创了区块链 2.0</p>\n<h2>比特币的历史</h2>\n<p>1999 年由密码学大牛组建密码朋克（cypherpunk）论坛，之后产生过一些数字货币，直到 20008 年，一个中本聪的 id 在密码朋克论坛中发表了比特币白皮书。哈尔芬尼，比特币的第二父亲，密码朋克论坛成员，密码学大牛，已去世。中本聪曾活跃在 bitcointalk 论坛，但在发生维基解密事件后消失。在此之后国内爆发了挖矿浪潮。而国外，则是由 V 神在比特币社区发布了 eth 白皮书，并带领团队筹集了 31000 个比特币，总共 1800 万美元，在瑞士成立了 eth 基金会，开启了区块链 2.0，2015 年 eth 主网上线，开启了 eth1.0。2016 年 eth2.0 的发布，稳固了 eth 生态，让公链生态走上 c 位。同年，比特币迎来第二次挖矿减半。</p>\n<p>2017 年 3 月，因为比特币的容量问题，以中国矿工为首的一派和以美国比特币核心维护团队一派产生了不同意见（一方主张直接扩容，一方主张以闪电网络和隔离验证来解决），所以比特币的第一次硬分叉诞生，以吴忌寒为首的比特大陆发布了比特币现金（BCH），区块容量从 1M 提升为 8M，效率是原来的 8 倍，巅峰时曾经算力是比特币（BTC）的两倍，但因为价格问题，最终还是走向了算力崩溃，不过 BCH 也走出了自己的道路。<br>\n2018 年比特币现金（BCH）又发生了分叉，一派是以 CSW 博士为代表的 BSV 版本派（主张 BCH 应该像中本聪论文所描述的那样，专注于数字货币的转账交易，并将区块扩容为 128M），另一派是以吴忌寒为代表的 ABC 版本派（主张在当前环境下，BCH 应该像以太坊一样，往基础建设公链的方向发展，开拓出更多应用场景，增强 BCH 的竞争力），双方决定通过算力来决定谁来获取比特币现金的继承权，赢者是主链，通过比较谁能挖出更多的区块来决定，最终 ABC 派获胜，不过 BSV 派也独立了出来，单独成立了一条链，这场大战造成了加密货币市值的腰斩。</p>\n<h2>NFT 初探</h2>\n<p>NFT 本质就是原来的东西+数字签名，用户可以通过 NFT 平台去验证来鉴别真假。</p>\n",
            "url": "https://clark-cui.top/posts/区块链科普.html",
            "title": "区块链科普",
            "summary": "区块链基础知识",
            "date_modified": "2022-04-27T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>linux shell</h3>\n<ul>\n<li>mv [OPTIONS] source destination 将一个文件或目录重命名或移动到另一个位置</li>\n<li>pwd 打印当前位置</li>\n<li>vi 编辑当前文件</li>\n<li>nano 一些 Linux 系统默认文件编辑器，比 vim 简单，^ 是 ctrl,M-是 alt，但是我们<a href=\"https://www.cnblogs.com/kaishirenshi/p/12194312.html\">应该把他修改为 vim</a></li>\n<li>ls (ls -a 展示所有文件) 展示文件</li>\n<li>mkdir 创建文件夹</li>\n<li>touch 创建文件</li>\n<li>cp [options] source dest ( -r 若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件) 复制文件</li>\n<li>cat /etc/passwd 查看用户信息</li>\n<li>sudo adduser username 创建用户（用户的目录在/home/user）</li>\n<li>sudo usermod -aG sudo username 把用户添加到 sudo 组（拥有 sudo 访问权限）</li>\n<li>sudo deluser username 删除用户</li>\n<li>sudo deluser --remove-home username 删除用户并且删除用户的家目录</li>\n<li>su user 切换用户(切换 root 需要 sudo su root，重开 terminal 默认就是 root)</li>\n<li>sudo passwd user (root 用户操作，重置密码,密码存储在 bitwarden)</li>\n<li>配置不同用户的环境\n<ul>\n<li>修改所有用户的环境变量：/etc/profile 文件</li>\n<li>只修改 root 用户的环境变量：~/.bashrc 文件（也就是/root/.bashrc）</li>\n<li>只修改某个非 root 用户的环境变量：/home/非 root 用户名/.bashrc 文件</li>\n<li>理论上的最佳实践是，开启 wsl2，新建一个 root 组的用户 clark,然后所有配置都在 clark 用户操作，因为 electron build 如果是 root 用户会有问题（需要加 --no-sandbox，如果是依赖的话就加不了这一行）</li>\n</ul>\n</li>\n</ul>\n<h3>安装 VMware</h3>\n<ul>\n<li>先在 423down 搜索 VMware Workstation PRO(阿里云盘里有 16 版本)</li>\n<li>安装，安装时注意勾选 WHP，为了兼容 windows 的 Linux 子系统的虚拟机 Hyper-v</li>\n<li>其他均默认即可</li>\n</ul>\n<h3>安装 Linuxmint</h3>\n<ul>\n<li><a href=\"https://linuxmint.com/download.php\">linuxmint 官网下载 cinnamon edition 版本的 iso</a></li>\n<li>打开 vmware，创建新的虚拟机，选择自定义（高级），均默认，注意选择 iso 的文件地址，然后一直完成后即可</li>\n<li>Start linux mint，进入桌面后，点击桌面光盘 install linux mint，如果没反应就重启试试，这时候是有点卡，然后全都默认设置，设置下 root 用户和密码，完成后重启</li>\n<li>此时桌面是小窗，还有点卡，点击 Vmware 的设置栏“虚拟机”，点击&quot;安装 VMware tools&quot;，如果这一栏是灰色，则<a href=\"https://www.jianshu.com/p/af4313d92fee\">按照这里操作</a>，也就是先关闭虚拟机，选择虚拟机设置，添加“软盘”，添加“CD/DVD”,使用物理驱动器连接，然后开启虚拟机，点击“重新安装 VMware Tools”</li>\n<li>桌面会有 VMware Tools 的软盘，点击打开，再点击打开 vmwareTools-10.3.10-13333.tar.gz,点击工具栏的“Extract”，选择目录“DownLoads”，然后打开 terminal，sudo su root,进入 DownLoads 目录，进入该文件夹， ./vmware-install.pl 执行安装脚本，然后一路回车即可安装完成，参考<a href=\"https://blog.csdn.net/weixin_43059285/article/details/103352682\">这里的后半段</a></li>\n<li>编辑虚拟机设置，选项，共享文件夹，选择总是启用（方便文件传输），然后添加一个文件夹用于 share,此文件夹在虚拟机的路径是/mnt/hgfs/filesName</li>\n<li>编辑虚拟机设置，选项，高级，为启用了 Hyper-V 的主机禁用侧通道缓解（提升性能）</li>\n<li>里面安装 cfw，下载 tar.gz 文件，双击打开，点击 extract 解压缩，然后在当前打开命令行，输入./cfw，</li>\n<li>然后配置本机走 cfw 的代理即可（里面的 firefox 浏览器默认是走的本机的配置，所以只需要配置本机代理接口，设置-network-proxy，manual-设置 127.0.0.1:8080,把 cfw 的端口改成 8080,并设置为开机启动）</li>\n<li>代理这里会有一点问题，就是虚拟机里面开不了 tun mode，只能手动配置代理，其实不太方便，虚拟机的网络走的是 NAT 模式，网络上有把其改为桥接模式，然后外围的 windows 的 clash 开启 lan，里面连接外围代理的设置，但我觉得没有我的这种好</li>\n<li>目前遗留了一个 bug，就是 VMtools 的跨系统自动鼠标指针和跨系统的复制粘贴不能用，不清楚是什么原因，查了下，应该是 VMtools 的部分功能没起作用，在配置了试了下，没啥用。目前是可用状态，就不折腾了</li>\n</ul>\n<h3>安装 manjaro-kde</h3>\n<ul>\n<li><a href=\"https://manjaro.org/downloads/official/kde/\">官网下载对应 iso</a>，下载后文件放入对应位置</li>\n<li>安装过程一致，选择经典，但是自己把内存调大点，注意，语言一定要选择英文，不然最后文件夹名会是中文（如果不小心弄了中文，除了重装，还有曲线救国的方法<a href=\"https://segmentfault.com/a/1190000037454534\">链接</a>），在命令行里就是很长的一串字符，特别麻烦，选完后，编辑配置，高级，设置共享文件夹和禁用侧通道，然后开启虚拟机，安装系统</li>\n<li><a href=\"https://www.liangzl.com/get-article-detail-206412.html\">我使用的分区信息都在这里，参考链接</a></li>\n<li><a href=\"https://blog.csdn.net/cxy1430826258/article/details/105050867\">参考链接二，我的炫龙里的镜像没有使用这个，但是可以参考</a></li>\n<li>安装太慢了...对比 mint 配置也很繁琐...但是界面真的很新颖，跟 mint 上个世纪的页面比，好看很多</li>\n<li>如果分辨率有问题，重启下虚拟机就好了</li>\n<li>然后就是配置软件源，设置代理软件（安装 cfw），安装常用软件</li>\n<li>配置下中文输入法，alt+space 唤起搜索，输入 input，进入 config，选择 Pinyin, shortcut 里有写 ctrl+space 切换输入法</li>\n<li>在 linux-mint 中，无法复制粘贴和无法拖动文件的 bug 在这里却没有复现，但是共享文件夹却没有挂载到/mnt/目录，也不知道为啥...<a href=\"https://zhuanlan.zhihu.com/p/344845390\">参考这里的链接应该能解决</a>，我就不折腾了，都能复制粘贴了，我还要共享文件夹干嘛...</li>\n<li>最后遗留一个坑，<s>cfw 是装上了，但是系统代理配置了没起作用，没时间折腾了，下次有机会再看吧，做饭了</s> 系统代理设置了，火狐浏览器设置自动跟随系统无效，设置手动 127.0.0.1:8080 后成功</li>\n</ul>\n<h3>总结</h3>\n<ul>\n<li>不同的镜像竟然有不同的坑,linux 桌面端果然是个大坑...坚定了我继续用 windows+wsl2 的道路...或者直接用 mac 也行，啥都帮我弄好了，相信 less is more</li>\n</ul>\n",
            "url": "https://clark-cui.top/posts/虚拟机配置.html",
            "title": "虚拟机配置",
            "summary": "配置虚拟机开发环境",
            "date_modified": "2022-01-20T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>背景</h2>\n<p>今天早上耍着手机，去 github 看了下我的仓库，点击博客地址打开发现竟然是空的，这可吓坏我了。重新试了几次发现还是一样的，把地址粘贴到浏览器打开就好使。查了下资料，原因是 github app 强制 https，而我的网站还是 http 的... 好吧，许久之前埋下的坑，就今天来填吧...</p>\n<h3>现状</h3>\n<p>服务器是买的 Ucloud 的，没啥，就是便宜。之前的建站过程中，我分了 4 个块，主站，blog 站，note 站，box 站，note 和 box 都是一个默认的 html，主站用 threejs 跑了个 demo,博客站用的 vuepress-reco 主题构建的。</p>\n<p>时间长了以后，主站被我废弃了，前段时间萌生了自己写个博客站的想法，说干就干，然后博客站就是主站了，不再做区分。</p>\n<blockquote>\n<p>最近有一些观察和思考。有些人的主站就是为了炫，做的特别酷，过段时间更新一下。有些人就干脆把主站当大杂烩，博客笔记啥的都在上面，比如 vuepress。对我来说，我还是比较喜欢把博客当主站，用一个 home page 的自我介绍就当作主页了，在这里可以外挂笔记站和玩具站。后续笔记站会用 Logseq Publish 构建，玩具站大概会放些 demo 工具之类的。</p>\n</blockquote>\n<p>在我肝了几天把新的博客站（主站）更新了出来后发生了今早的问题。</p>\n<h2>开干</h2>\n<h3>目标</h3>\n<p>主域名(clark-cui.top) 与子域名(blog.clark-cui.top, note.clark-cui.top,box.clark-cui.top)均开启 https</p>\n<h3>方案</h3>\n<p>毫无疑问，肯定是 let's encrypt。国内一些云服务厂商有代处理的业务，但是基本都收费，价格不菲...然而看起来他们也是用的 let's encrypt。一番查阅后，决定使用自动化工具 cerbot，到期自动续，看起来很不错，试一试把</p>\n<h3>问题</h3>\n<p>服务器里之前建站的时候，http 服务器是用的 docker 的 nginx 镜像构建的，然而 cerbot 的 docker Image 看起来已经好久没更新了...也没啥人这么用。我尝试了一下，每输一个命令，就会报一个新的错...吓坏我了...我这个 docker 菜鸟在容器里折腾了半天，决定放弃了...能力不够，还是老实按照官网来</p>\n<p>这也应征了那句话“Less is more”，搞不懂我当初就一个 Nginx，为啥还要装个 docker 装逼...</p>\n<p>然后安装 nginx，还会跟 docker 里的有端口冲突，在把容器和镜像都删干净之后，几行命令装好 nginx</p>\n<pre><code class=\"language-bash\">sudo yum install nginx\nsudo systemctl enable nginx\nsudo systemctl start nginx\nsudo systemctl status nginx //检查其运行状态\n</code></pre>\n<p>装好的 nginx 程序目录在/etc/nginx，把之前 docker 里配过的 default.conf 粘过来即可。域文档的目录在/usr/local/src</p>\n<p>然后是安装 cerbot,cerbot 的官网推荐先安装 snapd，再用 snapd 安装 cerbot。<a href=\"https://certbot.eff.org/instructions?ws=nginx&amp;os=centosrhel8\">官方文档安装 cerbot</a></p>\n<p>然而我在<code>sudo snap install core; sudo snap refresh core</code>那里卡住了，死活过不去。</p>\n<p>重复提示这俩报错，跟死循环一样：</p>\n<ul>\n<li>\n<p><code>error: cannot communicate with server</code></p>\n</li>\n<li>\n<p><code>Job for snapd.service failed because the control process exited with error code</code></p>\n</li>\n</ul>\n<p>全是 known issues，网上一堆解决办法...然而全都没用，去 cerbot 的 form 里找了找，也没啥用</p>\n<p>这个时候，我想另辟蹊径，既然装不了 snapd，那我不装你总行了吧，找了找，cerbot 还真有 yum 包，名字叫<code>cerbot-nginx</code>，然而我一看更新时间，醉了...都啥时候的了，看来还是躲不开</p>\n<p>既然是安装 snapd 的问题，那我重新安装不就行了，按照 windows 重启就好的思路，重装，重启，我甚至重启了服务器...然而问题依旧</p>\n<p>思考了下，或许换个姿势装 snapd 就好了呢？然后 google 搜索 centsos 8 install snapd，还真找出几篇不一样的姿势</p>\n<p><a href=\"https://snapcraft.io/docs/installing-snap-on-centos\">官方文档安装 snapd</a></p>\n<p>解决问题:按照官网示例，但是有几点不同</p>\n<ol>\n<li>先升级 epel,<code>sudo dnf upgrade</code> ，然后发现 700 多 M，没事，忍着头皮升，再次输入，并加上 <code>--allowerasing</code></li>\n<li>把<code>sudo yum install snapd</code>换成<code>sudo dnf install snapd </code></li>\n<li>在 create a symbolic link 之后，如果<code>sudo snap install core; sudo snap refresh core</code>报错<code>error: too early for operation, device not yet seeded or device model not acknowledged</code>，就输入命令<code>sudo dnf reinstall snapd</code>重装一下</li>\n</ol>\n<p>然后按照官网的示例接着装</p>\n<p>最后能看到下面这张图<br>\n<img src=\"../public/cerbot.png\" alt=\"成功的图片\"></p>\n<p>热泪盈眶啊，有没有...</p>\n<h2>总结</h2>\n<p>这次踩坑花了一下午时间，报错的时候去看日志，能看到错误的信息，但由于我不知道是啥，所以信息也没啥用，还得靠 Google,所以我还是得恶补一下操作系统的知识。</p>\n<p><s>然后刚又发现了新问题，站点是 https 的，但我博客文章里的图片，之前上传到七牛云图床的时候，绑定的域名是 cdn.clark-cui.top，是 http 的...在 https 的站点里就不加载了....要搞的话，得把 cdn 的域名也弄成 https...我醉了。想了下，我之前搞的这个图床 cdn 使用率基本小于 1%，目前没需求那就是没用，我还是把原图扣出来吧。</s></p>\n<p>Done,</p>\n<p>Cheers!</p>\n",
            "url": "https://clark-cui.top/posts/博客开启https.html",
            "title": "博客开启https",
            "summary": "所有子域名都开启了https",
            "date_modified": "2022-01-11T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>生活</h2>\n<p>大学在成都，毕业后去济南，现在在北京。前段时间从回龙观搬到了奥运村，周末会去旁边的奥森跑步</p>\n<h2>效率</h2>\n<p>我是一个喜欢折腾的人，折腾了许多工具，有句古话‘差生文具多’，但从我的层面，我折腾往往只是为了提升效率，有时候或许只是一点点的提升，应用到大量场景的时候，累计起来，收益还是很可观的</p>\n<h3>博客</h3>\n<blockquote>\n<p>我的博客几经变更，虽然有些内容丢失了，但还是保存下来了一些。<br>\n最初我把所有内容都放在博客，但我实践了一段时间后，意识到一些零碎的记录其实不适合放在博客，博客应该是类似 newsletter 的形式，要有好的阅读体验，然而我没啥时间整理格式（懒），所以博客内容总共加起来也没有很多。反倒是之前在济南，Leader 要求做技术分享的日子，积累了一些排版还过得去的博客，然而丢失的内容就是这些...</p>\n</blockquote>\n<p>而且，我发现自己以前写的一些技术文章，现在去看能发现明显的错误。所以我觉得，在输出之前，还是要好好内化一下知识。我还是需要更多的输入和处理，避免输出误人的内容。</p>\n<p>综上，博客就是随缘更新的。</p>\n<h3>工具</h3>\n<blockquote>\n<p>工具是第一生产力，通过使用工具能够快速做到某一领域的最佳实践</p>\n</blockquote>\n<p>这里推荐几个我认为很有意义的工具把：</p>\n<h4><strong>Wakatime</strong></h4>\n<p>用在 code editor 里装插件的形式使用。可以统计你的 code activity，官网的看板很不错。可视化自己的 coding 动态，来分析自己的工作状态，对应做出调整。</p>\n<p>关于这一点可以参考现代运动员，在训练甚至比赛的时候都会佩戴各种监测设备，有专业团队分析数据。这是一个好的方式，毕竟数据是最可靠的，</p>\n<h4><strong>Logseq</strong></h4>\n<p>今年最大的惊喜。简单介绍下，就是个开源的双链笔记，我给它贡献过几次代码。</p>\n<p>关于 Logseq，已经有很多优秀的英文文章和视频的介绍。但是中文的内容还比较少，我后续会写一篇博客介绍下它。</p>\n<h4><strong>加湿器</strong></h4>\n<p>以前一直觉得这是个智商检测电器，来了北京后，鼻子每时每刻都是阻的，太难受了，我明明没有鼻炎的，感觉再待个把月就得去医院看鼻子了...然后听朋友的，买了加湿器。en...天亮了</p>\n<h3>信息</h3>\n<p>现在是信息大爆炸的时代，无时无刻不在产生信息。信息的摄入方式多种多样，渐渐地，有人提出‘工作流’的观点，分享自己的信息处理流程。我也形成了一套自己的方法论，当然只适合当下我的需求，他随时会变，但是数据是不变的，这也是我为啥用 Logseq 的原因</p>\n<h2>运动</h2>\n<h3>足球</h3>\n<p>足球是本命，然而踢球太麻烦了，还容易受伤，已经大半年没踢了...</p>\n<h3>乒乓球</h3>\n<p>目前就偶尔和女朋友周末打打乒乓球</p>\n",
            "url": "https://clark-cui.top/posts/随便说点啥.html",
            "title": "随便说点啥",
            "summary": "吹吹水",
            "date_modified": "2022-01-10T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>背景</h2>\n<blockquote>\n<p>我是不喜欢用 mac，但是最近想给 Logseq 提代码，但是 windows 上跑不起来，discord 问了一圈，发现开发者都是用的 mac，所以他们就没有配 windows 的开发环境...</p>\n<p>然后试了 docker，但是在 windows 上跑一个 Playwright 的测试就是跑不起来...也 debug 不了，实在没辙了</p>\n<p>默默拿起公司配的 macbook，几分钟配好环境...真的方便，不得不承认，但是插上显示器的瞬间，我傻眼了，咋这么糊啊，我 2k 的显示器看着像 720p...</p>\n</blockquote>\n<h2>方案</h2>\n<blockquote>\n<p>遇事不决，先 Google,哦~果然是 known issue.</p>\n</blockquote>\n<p>大概调研了下，大致就是改下 mac 的配置文件，但是得进恢复模式改，类似 PC 的 bios 设置吧，有写好的脚本，直接用就行，比较坑的一点是如果系统更新，就得再来一遍。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/227788155?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1114657556978700288&amp;utm_campaign=shareopn\">放一篇写的不错的教程</a></p>\n",
            "url": "https://clark-cui.top/posts/mac外接显示器.html",
            "title": "mac外接显示器",
            "summary": "mac外接显示器的坑",
            "date_modified": "2021-10-15T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h2>tips</h2>\n<ul>\n<li>\n<p>传递数组或者对象作为函数参数时，可以用 Readonly&lt;&gt; 包裹原来的类型声明，譬如 <code>Readonly&lt;Array&lt;number&gt;&gt;</code>，TypeScript 编译器会通过拒绝编译来保护这个参数不被修改。如果的确需要一个可以被修改的数组，可以通过 spread 操作 [...array] 来复制这个数组</p>\n<ul>\n<li>\n<pre><code class=\"language-ts\">function sortNumbers(array: Readonly&lt;Array&lt;number&gt;&gt;) {\n  return [...array].sort((a, b) =&gt; a - b);\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>使用 unkown 而不是 any 来标注类型尚未明确的变量。Any 告诉 TypeScript 编译器，不需要检查类型；而 unkown 则是把检查留到使用变量的时候。使用时可以通过 typeof 运算符获取到变量的实际类型，通过 as 添加上类型后就可以正常使用了</p>\n</li>\n<li>\n<p>使用 Records 来代替 Objects，因为可以限定键的范围。如</p>\n<pre><code class=\"language-ts\">type AllowedKeys = &quot;name&quot; | &quot;age&quot;;\n\n// use a type here instead of interface\ntype Person = Record&lt;AllowedKeys, unknown&gt;;\n\nconst Human: Person = {\n  name: &quot;Steve&quot;,\n  age: 42,\n};\n</code></pre>\n</li>\n</ul>\n<h2>tsconfig</h2>\n<h3>隐式推断</h3>\n<p>ts 有隐式类型推断。开启后隐式 any 的推断会被检查并报错。</p>\n<pre><code class=\"language-typescript\">// x被隐式推断成any,抛出错误\nfunction getNum(x) {\n  return x;\n}\n// problems: Parameter 'x' implicitly has an 'any' type.\n</code></pre>\n<pre><code class=\"language-typescript\">// 主动声明x是any避免错误\nfunction getNum(x: any) {\n  return x;\n}\n</code></pre>\n<pre><code class=\"language-typescript\">// 这种情况不会报错，因为隐式推断成undefined\nlet y;\nconsole.log(y);\n</code></pre>\n<pre><code class=\"language-typescript\">// 这种情况也不会报错，因为赋值的时候类型推断成number\nlet z;\nz = 123;\nconsole.log(z);\n</code></pre>\n<h3>严格检查</h3>\n<p>默认情况 undefined 和 null 是其他类型的子类型，也就是其他类型变量可以被赋值 null 或 undefined。开启后会检查这种情况并报错。</p>\n<pre><code class=\"language-typescript\">let num: number = undefined;\n// problems:Type 'undefined' is not assignable to type 'number'.\n</code></pre>\n<h3>错误不输出</h3>\n<p>ts 默认即使编译报错也会生成 Js 文件，这一项设置 true,可以在报错的时候，不生成 js</p>\n<h2>基础</h2>\n<h3>标记类型</h3>\n<ul>\n<li>boolean,number,string,null,undefined</li>\n<li>void(一般用于函数空返回值，void 类型的变量可以赋值 undefined,不能赋值 null)</li>\n<li>any(允许被赋值给任意类型，any 类型不会被类型检查）</li>\n<li>unkonwn(允许被赋值给任意类型)</li>\n</ul>\n<h3>类型推论</h3>\n<p>定义时未指定类型且未赋值会被推断成 any，若赋值则会推断成赋值的类型</p>\n<pre><code class=\"language-ts\">let myFavoriteNumber = &quot;seven&quot;; //推断成string\n</code></pre>\n<h3>联合类型</h3>\n<p>‘或’</p>\n<pre><code class=\"language-ts\">let myFavoriteNumber: string | number;\n</code></pre>\n<h3>交叉类型</h3>\n<p>‘与’</p>\n<pre><code class=\"language-typescript\">interface A {\n  a: string;\n}\ninterface B {\n  b: string;\n}\nlet test: A &amp; B = {\n  a: &quot;test a&quot;,\n  b: &quot;test b&quot;,\n};\n</code></pre>\n<h3>对象的类型</h3>\n<h4>描述对象的形状（shape）</h4>\n<pre><code class=\"language-typescript\">interface Person {\n  name: string;\n  age: number;\n}\nlet tom: Person = {\n  name: &quot;Tom&quot;,\n  age: 25,\n};\n</code></pre>\n<h4>定义的变量比接口少一些属性或多一些属性都是不允许的</h4>\n<p>可选属性</p>\n<pre><code class=\"language-typescript\">interface Person {\n  name: string;\n  age?: number;\n}\n\nlet tom: Person = {\n  name: &quot;Tom&quot;,\n};\n</code></pre>\n<p>任意属性</p>\n<pre><code class=\"language-typescript\">interface Person {\n  name: string;\n  age?: number;\n  [propName: string]: any;\n}\n\nlet tom: Person = {\n  name: &quot;Tom&quot;,\n  gender: &quot;male&quot;,\n};\n</code></pre>\n<p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</p>\n<pre><code class=\"language-typescript\">interface Person {\n  name: string;\n  age?: number;\n  [propName: string]: string;\n}\n\nlet tom: Person = {\n  name: &quot;Tom&quot;,\n  age: 25,\n  gender: &quot;male&quot;,\n};\n\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.\n// index.ts(7,5): error TS2322: Type '{ [x: string]: string | number; name: string; age: number; gender: string; }' is not assignable to type 'Person'.\n//   Index signatures are incompatible.\n//     Type 'string | number' is not assignable to type 'string'.\n//       Type 'number' is not assignable to type 'string'.\n\n//上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。\n</code></pre>\n<p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p>\n<pre><code class=\"language-typescript\">interface Person {\n  name: string;\n  age?: number;\n  [propName: string]: string | number | undefined; // 因为age不一定有，可能是undefined\n}\n\nlet tom: Person = {\n  name: &quot;Tom&quot;,\n  age: 25,\n  gender: &quot;male&quot;,\n};\n</code></pre>\n<p>只读属性</p>\n<blockquote>\n<p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性<br>\n简单例子</p>\n</blockquote>\n<pre><code class=\"language-typescript\">interface Person {\n  readonly id: number;\n  name: string;\n  age?: number;\n  [propName: string]: any;\n}\n\nlet tom: Person = {\n  id: 89757,\n  name: &quot;Tom&quot;,\n  gender: &quot;male&quot;,\n};\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n// 上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n</code></pre>\n<p>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：</p>\n<pre><code class=\"language-typescript\">interface Person {\n  readonly id: number;\n  name: string;\n  age?: number;\n  [propName: string]: any;\n}\n\nlet tom: Person = {\n  name: &quot;Tom&quot;,\n  gender: &quot;male&quot;,\n};\n\ntom.id = 89757;\n\n// index.ts(8,5): error TS2322: Type '{ name: string; gender: string; }' is not assignable to type 'Person'.\n//   Property 'id' is missing in type '{ name: string; gender: string; }'.\n// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.\n//例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。\n</code></pre>\n<h3>数组的类型</h3>\n<h4>类型+方括号表示法</h4>\n<pre><code class=\"language-ts\">let fibonacci: number[] = [1, 2, 3, 4];\n</code></pre>\n<h4>泛型表示法（常用）</h4>\n<pre><code class=\"language-ts\">let fibonacci: Array&lt;number&gt; = [1, 2, 3, 4];\n</code></pre>\n<h4>接口表示法（不常见）</h4>\n<pre><code class=\"language-ts\">interface NumberArray {\n  [index: number]: number;\n}\nlet fibonacci: NumberArray = [1, 2, 3, 4];\n</code></pre>\n<h4>类数组的表示</h4>\n<p>类数组不是数组，不能用数组表示，但是可以参照接口表示法来写<br>\n比如函数参数 arguments。但事实上常用的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等</p>\n<pre><code class=\"language-ts\">function sum() {\n  let args: {\n    [index: number]: number;\n    length: number;\n    callee: Function;\n  } = arguments;\n}\n//上述等价于\nfunction sum() {\n  let args: IArguments = arguments;\n}\n//IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\ninterface IArguments {\n  [index: number]: any;\n  length: number;\n  callee: Function;\n}\n</code></pre>\n<h3>函数的类型</h3>\n<h4>函数声明式（简单，推荐）</h4>\n<pre><code class=\"language-ts\">function sum(x: number, y: number): number {\n  return x + y;\n}\n</code></pre>\n<h4>函数表达式</h4>\n<pre><code class=\"language-ts\">let mySum: (x: number, y: number) =&gt; number = (\n  x: number,\n  y: number\n): number =&gt; {\n  return x + y;\n};\n// 第一个冒号到第一个等号之间的可以省略，相当于不写type\n//ts会类型推断的，不然这么写\n//就像写了两遍\n\n//或者这么写，注意是Function不是function，其实也相当于少写了type\nlet newSum: Function = (x: number, y: number): number =&gt; {\n  return x + y;\n};\n</code></pre>\n<h4>用接口定义函数,注意参数的括号</h4>\n<pre><code class=\"language-ts\">interface SearchFunc {\n  (source: string, subString: string): boolean;\n}\nlet mySearch: SearchFunc = (source: string, subString: string): boolean =&gt; {\n  return source.search(subString) !== -1;\n};\n</code></pre>\n<h4>可选参数（可选参数要放在最后），参数默认值</h4>\n<pre><code class=\"language-ts\">function buildName(firstName?: string, lastName: string = &quot;Clark&quot;): string {\n  if (firstName) {\n    return firstName + lastName;\n  }\n  return lastName;\n}\n</code></pre>\n<h4>剩余参数，...rest 访问剩余参数</h4>\n<pre><code class=\"language-ts\">function myPush(array: Array&lt;unknown&gt;, ...rest: Array&lt;unknown&gt;) {\n  rest.forEach((item) =&gt; {\n    array.push(item);\n  });\n}\nmyPush([], 1, 2, 3);\n</code></pre>\n<h4>重载</h4>\n<p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理<br>\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'</p>\n<pre><code class=\"language-ts\">function reverse(x: number | string): number | string | void {\n  if (typeof x === &quot;number&quot;) {\n    return Number(x.toString().split(&quot;&quot;).reverse().join(&quot;&quot;));\n  } else if (typeof x === &quot;string&quot;) {\n    return x.split(&quot;&quot;).reverse().join(&quot;&quot;);\n  }\n}\n</code></pre>\n<p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串<br>\n这时，我们可以使用重载定义多个 reverse 的函数类型：</p>\n<pre><code class=\"language-ts\">function reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void {\n  if (typeof x === &quot;number&quot;) {\n    return Number(x.toString().split(&quot;&quot;).reverse().join(&quot;&quot;));\n  } else if (typeof x === &quot;string&quot;) {\n    return x.split(&quot;&quot;).reverse().join(&quot;&quot;);\n  }\n}\n//上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n\n//注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n</code></pre>\n<h3>类型断言</h3>\n<h4>语法</h4>\n<ul>\n<li>值 as 类型（推荐）</li>\n<li><code>&lt;类型&gt;</code>值 （不推荐，tsx 语法中<code>&lt;Foo&gt;</code>表示 ReactNode；而在 ts 中泛型也是这种语法，容易混淆）</li>\n<li>作用：给一个类型断言，让 ts 编译器听你的，若使用不当会造成运行时错误。常用于 ts 的一些不好解决的报错</li>\n<li>示例</li>\n</ul>\n<pre><code class=\"language-ts\">interface Cat {\n  name: string;\n  run(): void;\n}\ninterface Fihs {\n  name: string;\n  swim(): void;\n}\nfunction isFish(animal: Cat | Fish) {\n  if (typeof (animal as Fish).swim) {\n    return true;\n  }\n  return false;\n}\n</code></pre>\n<pre><code class=\"language-ts\">(window as any).foo = 1;\n</code></pre>\n<pre><code class=\"language-ts\">function getCacheData(key: string): any {\n  return (window as any).cache[key];\n}\n\ninterface Cat {\n  name: string;\n  run(): void;\n}\n\nconst tom = getCacheData(&quot;tom&quot;) as Cat;\ntom.run();\n</code></pre>\n<pre><code class=\"language-ts\">//用泛型可以更好地实现上述代码\nfunction getCacheData&lt;T&gt;(key: string): T {\n  return (window as any).cache[key];\n}\n\ninterface Cat {\n  name: string;\n  run(): void;\n}\n\nconst tom = getCacheData&lt;Cat&gt;(&quot;tom&quot;);\ntom.run();\n</code></pre>\n<h3>声明文件</h3>\n",
            "url": "https://clark-cui.top/posts/TypeScript学习笔记.html",
            "title": "TypeScript学习笔记",
            "summary": "typescript学习笔记",
            "date_modified": "2021-09-03T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>需求</h3>\n<blockquote>\n<p>背景：tts 老版代码是用 flash 写的，源码也找不到了。由于各大浏览器开始禁用 flash 功能，所以需要用 H5 重构</p>\n<p>tts 是什么：就是一个富文本编辑器，通过格式化编辑文本，调用后端文字转语音的接口生成听力材料并播放。</p>\n</blockquote>\n<ul>\n<li>第一版要求功能的复制，并修复一些 bug</li>\n<li>后续要求功能的优化，并增加一些功能</li>\n<li><img src=\"../public/20210414120037.png\" alt=\"img\"></li>\n</ul>\n<h3>技术选型</h3>\n<ul>\n<li>外围的界面由于 UI 简单故使用原生 JS 和 Css 编写。Mizar 在技术选型的时候，正是 Vue3 正在推广的时候，由于依赖关系比较单一，所以进行了 Vue3 的尝鲜。</li>\n<li>考虑到 UI 组件比较多，所以使用了 ELEMENT-Plus（不用 Ant Design Vue（Less））</li>\n<li>一开始使用 Vue-CLI 生成模板，后续因为几项 Bug，而且 VueCli 的黑箱机制，定位问题比较困难，所以参考 VueCli 的源码重写了一套模板配置。（由于文档不全，出了问题也找不到方案，最初是在 Vue form 里提问 然后有人帮解决的）</li>\n<li>打包工具用的 webpack v5,项目里配置了 eslint 和 prettier 的规则，用的规范是 <a href=\"https://github.com/AlloyTeam/eslint-config-alloy\">alloy-config</a>。</li>\n</ul>\n<h3>方案</h3>\n<ol>\n<li>\n<p>为了保证外部调用，抽出编辑器部分 Mizar，并把接口调用都抛出来。外部 UI 放在 Proxima，通过 UMD 的形式调用 Mizar。</p>\n</li>\n<li>\n<p>编辑区域实际就是一个富文本编辑器，因为有标签的存在，所以不能用 textArea。参考了一些主流的富文本编辑器的实现，选用</p>\n</li>\n</ol>\n<pre><code class=\"language-html\">contenteditable=&quot;true&quot;\n</code></pre>\n<ol start=\"3\">\n<li>编辑器需要获取选区，使用浏览器的 selection api。</li>\n<li>编辑器需要插入和删除 dom，使用浏览器的 range.insert 和 range.deleteContents api 。</li>\n</ol>\n<h3>项目结构</h3>\n<img src=\"../public/20210413231645.png\" alt=\"image-20210413231642326\"  />\n<h3>核心功能的实现</h3>\n<h4>鼠标光标的缓存</h4>\n<blockquote>\n<p>在编辑器里，鼠标选择内容后，并不会立即插入标签，后续会点击弹窗、下拉框，在点击的时候就会导致 selection 对象改变。当用户拖选内容的时候，如果鼠标脱离编辑器，那此时的 selection 对象就会是空。如果用户用键盘操作光标，selection 对象不会更新。</p>\n</blockquote>\n<p><strong>参考了一些开源文本编辑器的实现，这里都是做了光标缓存的处理。slection 事件触发的时候，记录用户单击或者拖选的 selection。监听鼠标离开事件，离开时就记录离开时的 selection。监听键盘事件，重置 selection</strong></p>\n<h4>内容校验</h4>\n<blockquote>\n<p>内容校验有 3 个入口：初始化页面，获取页面内容的时候；保存/播放的时候；粘贴内容的时候。</p>\n</blockquote>\n<ol>\n<li>初始化页面：由于由许多 flash 编辑的听力材料数据，所以需要把 falsh 的数据转换为 H5 支持的数据格式。目前的逻辑是，编辑器支持编辑老的数据，但是 h5 编辑器编辑过的数据，flash 版的编辑器就不再支持。这里过滤主要用正则白名单过滤，把 flash 的信息和一些样式属性，class，不支持的标签都过滤掉。匹配换行符和换行标签，还有块标签，根据标签分组，每一行都用 p 标签包裹。行内正则匹配文本（用没有&lt;&gt;的文字和符号），每一段文本都用 span 标签包裹，给图片标签都添加唯一标识。因为 flash 图片的 source 不能用于 H5,格式不一致，所以需要根据图片 id，查本地的表，获取图片 url。</li>\n<li>保存/播放：基本逻辑与初始化一致</li>\n<li>粘贴内容：如粘贴功能所述</li>\n</ol>\n<h4>粘贴功能</h4>\n<blockquote>\n<p>线上的粘贴文本在粘贴 word 或者网页的时候会有 bug。</p>\n<p>此处编辑器 H5 的实现是用了 contenteditable,所以理论上是可以粘贴 html。如果不禁止默认粘贴事件，那么编辑器内可以粘贴任意来源会被存到剪贴板的内容。但由于接口生成音频需要匹配对应的 html 格式，同时不能带有白名单之外的内容，所以必须做内容过滤。</p>\n</blockquote>\n<ul>\n<li>粘贴功能第一版做了简单的处理，粘贴的时候只粘贴纯文本。实现的方案就是判断文本有无换行，没有换行就插入<code>&lt;span&gt;</code>标签包裹的文本。有换行，就根据换行分组，分别插入<code>&lt;p&gt;</code>标签包裹的文本，每次插入后都会调用 range.collapse(false)收缩光标至插入内容之后（chrome56 以下不一致）。</li>\n<li>由于会有许多在当前编辑器粘贴内容，或者是打开过去编辑的内容，粘贴到新的编辑器之类的需求。所以做了区分来源的处理，剪贴板无法直接判断来源，但可以根据内容来判断来源。我会根据标签的 id 来判断，只要有不是我 id 的内容，就会被当作纯文本粘贴。都是我 id 的内容，会被当作 html 粘贴。</li>\n<li>用户在当前位置粘贴，还是选择内容后粘贴，这里做了处理。如果是选择内容，会调用 deleteContents 方法删除内容后，再插入标签。最后会调用 selection.collapseToEnd 收缩光标至末尾。</li>\n</ul>\n<h4>标签错误提示闪烁</h4>\n<blockquote>\n<p>需求是有标签缺失或者错位的时候，需要闪烁提示错误的标签</p>\n</blockquote>\n<p><img src=\"../public/20210414121928.gif\" alt=\"错误提示\"></p>\n<ol>\n<li>\n<p>标签错误提示这里，有两种提示的方式。一种是用户编辑的时候提示，一种是用户播放/保存的时候提示。这里使用的是第二种。</p>\n</li>\n<li>\n<p>错误检测这里，使用的方法是用 selection api 先获取要检测内容的 html 字符串，为了定位错误标签，给所有的标签都加上了 guid 唯一标识。（这里第一版做的时候，单标签插入的是唯一标识，双标签插入的是相同的标识，错误检测的时候检测到双标签标识的缺失非常容易。但会有一个问题，当检测出错误标签后，用户不删除当前错误标签，选择插入一对相同的标签，再删除新增的那项。由于这对标签不是同时生成，故 guid 不同，导致错误检测出 bug）</p>\n<p>目前用的是一个栈的思想，维护一个错误栈和一个左栈，遇到一个左标签就 push 进栈，遇到一个右标签就比较最后一个元素，如果不匹配，把右标签 push 进错误栈，如果匹配，左标签 pop 出栈，最后把剩余的左栈加入错误栈，所有元素就是错误的项。</p>\n</li>\n</ol>\n<h4>音频播放</h4>\n<blockquote>\n<p>音频播放这里，会有播放单个音频和顺序播放音频数组的情况，接口为了减少单词请求量，把请求数据按 p 标签分组。</p>\n</blockquote>\n<p>自己封装了 ttsAudio</p>\n<blockquote>\n<p>播放音频数组，每一段音频结束后都会有 0.5s 左右的暂停时间，这段时间并没有在音频里生成。所以需要前端手动暂停，前端用的 setTimeOut 实现的暂停。</p>\n<p>这里会有一个问题就是，播放音频数组，当一段音频刚好结束，用户点击播放暂停，去调用 audio.pause()方法会失效。</p>\n</blockquote>\n<p>这里解决的办法是，调用暂停的时候就判断是播放时暂停，还是结束时暂停。如果是播放时暂停就正常暂停，后续可以续播。如果是一段结束时暂停，每段播放结束，数组就 shift，暂停时就清除掉 audio 对象，续播时新建 audio 播放剩余数组</p>\n<h4>插入标签</h4>\n<blockquote>\n<p>插入标签分为 3 种，插入单标签，插入双标签，插入对话标签</p>\n</blockquote>\n<p><img src=\"../public/20210414121015.gif\" alt=\"插入对话\"></p>\n<p>这里做了选择内容的校验：</p>\n<ol>\n<li>如果用户鼠标是光标聚焦状态，此时可以仅可以在光标位置插入单标签，其余会给弹窗提示</li>\n<li>如果用户选择了内容，且内容不是对话的格式，此时仅可以在选择内容两端插入双标签，其余项置灰不可点击（还有根据选择内容的中英文，过滤插入标签的选择项）</li>\n<li>如果用户选择了内容，且是对话的格式，此时可以插入双标签，也可以插入对话标签</li>\n</ol>\n<p><strong>插入标签这里，有两种方案，第一种是 document.execCommand，另一种是操作字符串。</strong></p>\n<p>比较简单的方式肯定是操作字符串，但是初期调研的时候。苦于修改字符串后对位替换会有各种 bug...(sel 对象获取的 Html string 于 innnderHtml 获取的不一致，会有标签缺失（最后一个 br），字符转义 nbsp;...)</p>\n<p>所以初期都使用了 document.execCommand 插入标签，这也是许多富文本编辑器使用的方式，但是在插入对话标签的时候会有问题 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Selection/modify\">selection.modify</a></p>\n<p>因为会有一个人一次性说多句话导致换行的情况，modify api 没有合适的参数，期间尝试用 extend character 去试探检测冒号，但是在许多边角情况出现了死循环，解决了许多边角情况，但因为输入的不确定性，所以处理很困难，期间出了许多 bug。</p>\n<p>因为许多富文本编辑器并没有类似的，同时插入多行标签的情况，所以没有找到参考的代码，相关文章也很少。</p>\n<p>后面在 github(app)刷到了一个项目，用了 range.deleteContents 方法删除了选中内容并在当前位置聚焦，跑通了方案二的逻辑。</p>\n<p>所以目前插入单双标签用的方案一，插入对话标签用的方案二。</p>\n<p>关于对话标签，有一个难点就是对话内容的检测，用什么来判断是一段话。因为会有多句话导致换行的情况，所以使用了:分割，:到非空的字符是人名，冒号后面一直到非空字符是句子。这样适配了出现换行的情况，但这样也会有一个问题就是，当对话内容里出现了冒号，比如 6：30，这种场景是比较高频的。</p>\n<p>所以比较适中的方案就是，检测主动换行，只要主动换行，就算作一段。</p>\n<p>调用 cloneContents 复制 fragment 对象，Fragment 是文档碎片，他不能当作普通的对象使用，可以用获取他的 innerHtml 字符串，再过滤一道。但最好的方式，就是新建一个空 div,然后使用 appendChild 录入当前 fragment，注意使用后的 fragment 会被清空。</p>\n<h3>注意的点</h3>\n<ul>\n<li>\n<p>为了减小包的体积，剔除了 Vue3,在 Proxima 里引用 Vue</p>\n</li>\n<li>\n<p>webpack 打包生产环境压缩 js 和 css 并自动删除注释</p>\n</li>\n<li>\n<p>sass-loder 用了 dart-sass，但是目前 dart-sass 配合 element-plus 使用的时候，会有图标样式缺失的情况（查看 issue 发现是 dart-sass 在编译的时候，默认会转换一遍 unicode 明文，会有双节字符乱码的情况）</p>\n<pre><code class=\"language-javascript\">对于图标编译之后，图标的content呈现乱码有dart-sass编译的原因，dart-sass编译时会将对应的unicode编码转换成对应unicode明文，所以通过伪元素来展示的图标如el-icon-arrow:before{ content: &quot;\\e6df&quot;}，编译之后就变成了el-icon-arrow:before{ content: &quot;&quot;}，“”便是一个双字节字符\n正常情况我们会在meta标签上设置：&lt;meta charset=&quot;utf-8&quot; &gt;，但这只对HTML内容解析有效，对于css内容中(外部样式表下)的双字节字符（如中文）解析并没有作用的，所以如果浏览器请求回来的css资源的HTTP响应头里的Content-Type未指明&quot;charset=utf-8&quot;的话，浏览器根据自身的嗅探机制来决定采用哪一种编码解析，结果就会概率出现双字节字符乱码的情况\n解决方案：\n1、使用 @charset\n2、使用 css-unicode-loader\n</code></pre>\n</li>\n<li>\n<p>项目里 Vue3 的写法，我用了 setup 和 methods 组合的写法，官方更推荐都写进 setup 里，我为了好看一点，把 methods 单独拿出来放在了外面，主要是单文件的东西有点太多了，都放在 setup 里比较长。</p>\n</li>\n<li>\n<p>根组件只有一个 APP，子组件有 3 个 Alert、Button、SecondAlert。这里有一些可以优化的地方，比如 App 和 Alert 的代码就比较长（不算样式文件 APP 超过 1600 行，Alert 超过 1000 行）。这里算是有一些历史原因，最初想把弹窗 Alert 封装成 vue 方法，通过 this.$alert直接调用，这样调用起来比较简洁。但是后续书写发现，弹窗代码和组件代码有许多逻辑耦合，方法于组件的通信比较困难，没有直接的方式，只能通过外部封装方法类的时候手动传入。所以把封装的方法挪出来当成了components，后续把一些代码拆到了SecondAlert，减少了一些代码量。APP根组件里可以把一些methods封装成全局方法，通过this.$method 调用，一些过滤方法，在 proxima 里也有重复的代码，可以提出来封装到导出的 mizar 类里，也可以减少一些代码量。</p>\n</li>\n</ul>\n",
            "url": "https://clark-cui.top/posts/TTS.html",
            "title": "TTS",
            "summary": "tts",
            "date_modified": "2021-05-03T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<blockquote>\n<p><a href=\"https://juejin.im/post/6844903607066689550\">https://juejin.im/post/6844903607066689550</a></p>\n<p>这篇文章讲的还可以，但是有一点讲错了，我在这里补充一下，再加几个常见的面试题。</p>\n</blockquote>\n<h2>要点</h2>\n<ul>\n<li>变量声明 var 和函数声明 function 都会有声明的提升，提升到函数作用域或者全局作用域的顶端，后面提升的排在之前提升的后面，重复的会覆盖之前的声明。</li>\n<li>先提升变量，相同的变量合并，赋值 undefined，再提升函数。</li>\n</ul>\n<h2>举几个例子</h2>\n<h3>变量声明与函数声明的提升顺序</h3>\n<pre><code class=\"language-javascript\">console.log(a); //Function\nfunction a() {\n  return 4;\n}\nvar a = 3;\nconsole.log(a); //3\n\n//相当于\nvar a = undefined; //先提升变量，变量全部提升完后，再提升函数\nfunction a() {\n  return 4;\n}\nconsole.log(a);\na = 3;\nconsole.log(a);\n</code></pre>\n<h3>变量声明的合并</h3>\n<pre><code class=\"language-javascript\">console.log(a)      //Function\nvar a=3;\nfunction a(){\n    return 4\n}\nvar a=4;\nconsole.log(a)      //4\n\n//相当于\nvar a =undefined；   //变量声明合并\nfunction a(){\n    return 4\n}\nconsole.log(a)\na=3;\na=4;\nconsole.log(a)\n</code></pre>\n<h3>提升到函数作用域顶部</h3>\n<pre><code class=\"language-javascript\">var a = 4;\n(function () {\n  if (typeof a == undefined) {\n    var a = 5;\n    console.log(a); //5\n  } else {\n    console.log(a);\n  }\n})();\n\n//相当于\nvar a = undefined;\na = 4;\n(function () {\n  var a = undefined; //提升变量到函数作用域顶端，并覆盖之前的声明\n  if (typeof a == undefined) {\n    a = 5;\n    console.log(a);\n  } else {\n    console.log(a);\n  }\n})();\n</code></pre>\n<h3>函数声明提升</h3>\n<pre><code class=\"language-javascript\">foo(); //'foo'\nbar(); //TypeError bar is not a function\n\nfunction foo() {\n  console.log(&quot;foo&quot;);\n}\n\nvar bar = function () {\n  console.log(&quot;bar&quot;);\n};\n\n//相当于\nvar bar = undefined; //先提升变量\nfunction foo() {\n  //提升函数声明\n  console.log(&quot;foo&quot;);\n}\nfoo();\nbar();\nbar = function () {\n  console.log(&quot;bar&quot;);\n};\n</code></pre>\n",
            "url": "https://clark-cui.top/posts/变量提升.html",
            "title": "js变量提升",
            "summary": "javascript的变量提升机制",
            "date_modified": "2020-12-08T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>chrome</h3>\n<p>chrome 安装 SwitchyOmega 把条件都删除，选择规则列表，autoProxy 规则网址填入 <a href=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> 立即更新情景模式(要开代理，注意不要被 switchyOmega 影响到，可以先把他设置为系统代理) 规则下设置 proxy 其他设置直接连接（此时本地代理工具无效），proxy 设置 127.0.0.1 端口 7890 应用选项 选择 auto switch</p>\n<h3>clash</h3>\n<ul>\n<li>开启 lan 模式，让内网能连接使用代理，用于 wsl2 连接代理</li>\n<li>开启 tun 模式，<a href=\"https://docs.cfw.lbyczf.com/contents/tun.html#windows\">文档地址</a>，为不走代理的软件走软件，开启后很多命令行都不用再设置代理，比如 wsl2</li>\n<li>一般开 clash 的 tun 模式就行，手动的地址是<code>http://127.0.0.1:7890</code></li>\n<li><a href=\"https://maofun.com/739.html\">clash 配合 switch 插件</a></li>\n</ul>\n",
            "url": "https://clark-cui.top/posts/proxyConfig.html",
            "title": "代理配置",
            "summary": "由于网络问题，需要做一些代理的设置，这里是我的一些记录",
            "date_modified": "2020-06-10T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        },
        {
            "content_html": "<h3>ucloud 服务器</h3>\n<ul>\n<li>主站和博客在/usr/local/src</li>\n<li>blog-clark-cui 与 homesite 都开启了自动上传 action 用 ftp 连接服务器上传的，服务器里的.git-ftp.log 文件就是记录的</li>\n</ul>\n<h3>关于图床的思考</h3>\n<ul>\n<li>图床不是必需品，感觉没啥用\n<ul>\n<li>防盗链</li>\n<li>http</li>\n<li>开启水印</li>\n<li>图形页面方便管理（没有哪一家实现了）</li>\n<li>删除（操作繁琐）</li>\n</ul>\n</li>\n<li>硬是要用的话就用现有的七牛云吧，都配置好了，配合 picgo</li>\n</ul>\n<h3>关于云托管的思考</h3>\n<ul>\n<li>腾讯云静态托管可用\n<ul>\n<li>有自动 https 域名</li>\n<li>但是依托空间，只有第一个空间免费</li>\n<li>如果有动态需求，只能用他的云数据库和云函数，体验不好</li>\n</ul>\n</li>\n<li>别的主机商的托管\n<ul>\n<li>国内访问慢</li>\n</ul>\n</li>\n<li>总结\n<ul>\n<li>可以做文档类的托管，主站还是不必了。不过都弄主站了，多弄个 nginx 托管似乎也没啥问题</li>\n</ul>\n</li>\n</ul>\n<h3>关于 tsl 证书</h3>\n<ul>\n<li>使用 cerbot,注意相关东西要装在 docker 里，Nginx 就在 docker 里，全局是没有的</li>\n</ul>\n<h3>关于 vitepress</h3>\n<ul>\n<li>新版的 vuepress 和 vitepress 类似，但是 vitepress 不支持插件系统</li>\n<li>使用 vitepress 重构主站，目前已经完成首页，还需要完成 blog 页\n<ul>\n<li>使用 nodejs 获取本地文件并处理头部参考 <a href=\"https://juejin.cn/post/6896382276389732359\">掘金</a></li>\n<li>具体案例参考 <a href=\"https://github.com/airene/vitepress-blog-pure\">vitepress-blog-pure</a></li>\n</ul>\n</li>\n<li>sidebar 使用 slug 组件，在 vitepress-for-component 里\n<ul>\n<li>完成品参考 <a href=\"https://github.com/dewfall123/vitepress-for-component\">vitepress-for-component</a></li>\n</ul>\n</li>\n</ul>\n",
            "url": "https://clark-cui.top/posts/buildSite.html",
            "title": "建站日记",
            "summary": "这是服务器建站的一系列记录，早期的版本已经遗失，这里是目前的一些实践与想法",
            "date_modified": "2020-01-10T00:00:00.000Z",
            "author": {
                "name": "Clark Cui",
                "url": "https://clark-cui.top"
            }
        }
    ]
}