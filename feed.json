{
    "version": "https://jsonfeed.org/version/1",
    "title": "你的饮月君",
    "home_page_url": "https://yinyuejun.top/",
    "feed_url": "https://yinyuejun.top/feed.json",
    "description": "你的饮月君' Blog",
    "icon": "https://yinyuejun.top/horse.svg",
    "author": {
        "name": "你的饮月君",
        "url": "https://yinyuejun.top"
    },
    "items": [
        {
            "content_html": "<h1>快速入门</h1>\n<p>本指南将会通过使用Electron创建一个极简的 Hello World 应用一步步的带你了解，该应用与<a href=\"https://github.com/electron/electron-quick-start\"><code>electron/electron-quick-start</code></a>类似。</p>\n<p>通过这个教程，你的app将会打开一个浏览器窗口，来展示包含当前正在运行的 Chromium, Node.js与 Electronweb等版本信息的web界面</p>\n<h2>Prerequisites</h2>\n<p>在使用Electron进行开发之前，您需要安装 <a href=\"https://nodejs.org/en/download/\">Node.js</a>。 我们建议您使用最新的LTS版本。</p>\n<blockquote>\n<p>请使用为你平台预构建的 Node.js 安装器来进行安装， 否则，您可能会遇到与不同开发工具不兼容的问题。</p>\n</blockquote>\n<p>要检查 Node.js 是否正确安装，请在您的终端输入以下命令：</p>\n<pre><code class=\"language-sh\">node -v\nnpm -v\n</code></pre>\n<p>这两个命令应输出了 Node.js 和 npm 的版本信息。</p>\n<p><strong>注意</strong> 因为 Electron 将 Node.js 嵌入到其二进制文件中，你应用运行时的 Node.js 版本与你系统中运行的 Node.js 版本无关。</p>\n<h2>创建你的应用程序</h2>\n<h3>使用脚手架创建</h3>\n<p>Electron 应用程序遵循与其他 Node.js 项目相同的结构。 首先创建一个文件夹并初始化 npm 包。</p>\n<pre><code class=\"language-sh\">mkdir my-electron-app &amp;&amp; cd my-electron-app\nnpm init\n</code></pre>\n<p><code>init</code>初始化命令会提示您在项目初始化配置中设置一些值 为本教程的目的，有几条规则需要遵循：</p>\n<ul>\n<li><code>entry point</code> 应为 <code>main.js</code>.</li>\n<li><code>author</code> 与 <code>description</code> 可为任意值，但对于<a href=\"#package-and-distribute-your-application\">应用打包</a>是必填项。</li>\n</ul>\n<p>你的 <code>package.json</code> 文件应该像这样：</p>\n<pre><code class=\"language-json\">{\n  &quot;name&quot;: &quot;my-electron-app&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;Hello World!&quot;,\n  &quot;main&quot;: &quot;main.js&quot;,\n  &quot;author&quot;: &quot;Jane Doe&quot;,\n  &quot;license&quot;: &quot;MIT&quot;\n}\n</code></pre>\n<p>然后，将 <code>electron</code> 包安装到应用的开发依赖中。</p>\n<pre><code class=\"language-sh\">$ npm install --save-dev electron\n</code></pre>\n<blockquote>\n<p>注意：如果您在安装 Electron 时遇到任何问题，请 参见 [高级安装][advanced-installation] 指南。</p>\n</blockquote>\n<p>最后，您希望能够执行 Electron 如下所示，在您的 <a href=\"https://docs.npmjs.com/cli/v7/using-npm/scripts\"><code>package.json</code></a>配置文件中的<code>scripts</code>字段下增加一条<code>start</code>命令：</p>\n<pre><code class=\"language-json\">{\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;electron .&quot;\n  }\n}\n</code></pre>\n<p><code>start</code>命令能让您在开发模式下打开您的应用</p>\n<pre><code class=\"language-sh\">npm start\n</code></pre>\n<blockquote>\n<p>注意：此脚本将告诉 Electron 在您项目根目录运行 此时，您的应用将立即抛出一个错误提示您它无法找到要运行的应用</p>\n</blockquote>\n<h3>运行主进程</h3>\n<p>任何 Electron 应用程序的入口都是 <code>main</code> 文件。 这个文件控制了<strong>主进程</strong>，它运行在一个完整的Node.js环境中，负责控制您应用的生命周期，显示原生界面，执行特殊操作并管理渲染器进程(稍后详细介绍)。</p>\n<p>执行期间，Electron 将依据应用中 <code>package.json</code>配置下<a href=\"https://docs.npmjs.com/cli/v7/configuring-npm/package-json#main\"><code>main</code></a>字段中配置的值查找此文件，您应该已在<a href=\"#scaffold-the-project\">应用脚手架</a>步骤中配置。</p>\n<p>要初始化这个<code>main</code>文件，需要在您项目的根目录下创建一个名为<code>main.js</code>的空文件。</p>\n<blockquote>\n<p>注意：如果您此时再次运行<code>start</code>命令，您的应用将不再抛出任何错误！ 然而，它不会做任何事因为我们还没有在<code>main.js</code>中添加任何代码。</p>\n</blockquote>\n<h3>创建页面</h3>\n<p>在可以为我们的应用创建窗口前，我们需要先创建加载进该窗口的内容。 在 Electron 中，每个窗口中无论是本地的HTML文件还是远程URL都可以被加载显示。</p>\n<p>此教程中，您将采用本地HTML的方式。 在您的项目根目录下创建一个名为<code>index.html</code>的文件：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;\n    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; script-src 'self'&quot;&gt;\n    &lt;meta http-equiv=&quot;X-Content-Security-Policy&quot; content=&quot;default-src 'self'; script-src 'self'&quot;&gt;\n    &lt;title&gt;Hello World!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello World!&lt;/h1&gt;\n    We are using Node.js &lt;span id=&quot;node-version&quot;&gt;&lt;/span&gt;,\n    Chromium &lt;span id=&quot;chrome-version&quot;&gt;&lt;/span&gt;,\n    and Electron &lt;span id=&quot;electron-version&quot;&gt;&lt;/span&gt;.\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>注意：在这个HTML文本中，您会发现主体文本中丢失了版本编号。 稍后我们将使用 JavaScript 动态插入它们。</p>\n</blockquote>\n<h3>在窗口中打开您的页面</h3>\n<p>现在您有了一个页面，将它加载进应用窗口中。 要做到这一点，你需要 两个Electron模块：</p>\n<ul>\n<li>[<code>app</code>][app] 模块，它控制应用程序的事件生命周期。</li>\n<li>[<code>BrowserWindow</code>][browser-window] 模块，它创建和管理应用程序 窗口。</li>\n</ul>\n<p>因为主进程运行着Node.js，您可以在文件头部将他们导入作为<a href=\"https://nodejs.org/docs/latest/api/modules.html#modules_modules_commonjs_modules\">公共JS</a>模块：</p>\n<pre><code class=\"language-js\">const { app, BrowserWindow } = require('electron')\n</code></pre>\n<p>然后，添加一个<code>createWindow()</code>方法来将<code>index.html</code>加载进一个新的<code>BrowserWindow</code>实例。</p>\n<pre><code class=\"language-js\">function createWindow () {\n  const win = new BrowserWindow({\n    width: 800,\n    height: 600\n  })\n\n  win.loadFile('index.html')\n}\n</code></pre>\n<p>接着，调用<code>createWindow()</code>函数来打开您的窗口。</p>\n<p>在 Electron 中，只有在 <code>app</code> 模块的 [<code>ready</code>][app-ready] 事件被激发后才能创建浏览器窗口。 您可以通过使用 [<code>app.whenReady()</code>][app-when-ready] API来监听此事件。 在<code>whenReady()</code>成功后调用<code>createWindow()</code>。</p>\n<pre><code class=\"language-js\">app.whenReady().then(() =&gt; {\n  createWindow()\n})\n</code></pre>\n<blockquote>\n<p>注意：此时，您的电子应用程序应当成功 打开显示您页面的窗口！</p>\n</blockquote>\n<h3>管理窗口的生命周期</h3>\n<p>虽然你现在可以打开一个浏览器窗口，但你还需要一些额外的模板代码使其看起来更像是各平台原生的。 应用程序窗口在每个OS下有不同的行为，Electron将在app中实现这些约定的责任交给开发者们。</p>\n<p>一般而言，你可以使用 <code>进程</code> 全局的 <a href=\"https://nodejs.org/api/process.html#process_process_platform\"><code>platform</code></a> 属性来专门为某些操作系统运行代码。</p>\n<h4>关闭所有窗口时退出应用 (Windows &amp; Linux)</h4>\n<p>在Windows和Linux上，关闭所有窗口通常会完全退出一个应用程序。</p>\n<p>To implement this, listen for the <code>app</code> module's [<code>'window-all-closed'</code>][window-all-closed] event, and call [<code>app.quit()</code>][app-quit] if the user is not on macOS (<code>darwin</code>).</p>\n<pre><code class=\"language-js\">app.on('window-all-closed', function () {\n  if (process.platform !== 'darwin') app.quit()\n})\n</code></pre>\n<h4>如果没有窗口打开则打开一个窗口 (macOS)</h4>\n<p>当 Linux 和 Windows 应用在没有窗口打开时退出了，macOS 应用通常即使在没有打开任何窗口的情况下也继续运行，并且在没有窗口可用的情况下激活应用时会打开新的窗口。</p>\n<p>To implement this feature, listen for the <code>app</code> module's [<code>activate</code>][activate] event, and call your existing <code>createWindow()</code> method if no browser windows are open.</p>\n<p>因为窗口无法在 <code>ready</code> 事件前创建，你应当在你的应用初始化后仅监听 <code>activate</code> 事件。 通过在您现有的 <code>whenReady()</code> 回调中附上您的事件监听器来完成这个操作。</p>\n<pre><code class=\"language-js\">app.whenReady().then(() =&gt; {\n  createWindow()\n\n  app.on('activate', function () {\n    if (BrowserWindow.getAllWindows().length === 0) createWindow()\n  })\n})\n</code></pre>\n<blockquote>\n<p>注意：此时，您的窗口控件应功能齐全！</p>\n</blockquote>\n<h3>通过预加载脚本从渲染器访问Node.js。</h3>\n<p>现在，最后要做的是输出Electron的版本号和它的依赖项到你的web页面上。</p>\n<p>在主进程通过Node的全局 <code>process</code> 对象访问这个信息是微不足道的。 然而，你不能直接在主进程中编辑DOM，因为它无法访问渲染器 <code>文档</code> 上下文。 它们存在于完全不同的进程！</p>\n<blockquote>\n<p>Note: If you need a more in-depth look at Electron processes, see the [Process Model][] document.</p>\n</blockquote>\n<p>这是将 <strong>预加载</strong> 脚本连接到渲染器时派上用场的地方。 预加载脚本在渲染器进程加载之前加载，并有权访问两个 渲染器全局 (例如 <code>window</code> 和 <code>document</code>) 和 Node.js 环境。</p>\n<p>创建一个名为 <code>preload.js</code> 的新脚本如下：</p>\n<pre><code class=\"language-js\">window.addEventListener('DOMContentLoaded', () =&gt; {\n  const replaceText = (selector, text) =&gt; {\n    const element = document.getElementById(selector)\n    if (element) element.innerText = text\n  }\n\n  for (const dependency of ['chrome', 'node', 'electron']) {\n    replaceText(`${dependency}-version`, process.versions[dependency])\n  }\n})\n</code></pre>\n<p>上面的代码访问 Node.js <code>process.versions</code> 对象，并运行一个基本的 <code>replaceText</code> 辅助函数将版本号插入到 HTML 文档中。</p>\n<p>要将此脚本附加到渲染器流程，请在你现有的 <code>BrowserWindow</code> 构造器中将路径中的预加载脚本传入 <code>webPreferences.preload</code> 选项。</p>\n<pre><code class=\"language-js\">// 在文件头部引入 Node.js 中的 path 模块\nconst path = require('path')\n\n// 修改现有的 createWindow() 函数\nfunction createWindow () {\n  const win = new BrowserWindow({\n    width: 800,\n    height: 600,\n    webPreferences: {\n      preload: path.join(__dirname, 'preload.js')\n    }\n  })\n\n  win.loadFile('index.html')\n}\n// ...\n</code></pre>\n<p>这里使用了两个Node.js概念：</p>\n<ul>\n<li>The <a href=\"https://nodejs.org/api/modules.html#modules_dirname\"><code>__dirname</code></a> string points to the path of the currently executing script (in this case, your project's root folder).</li>\n<li>The <a href=\"https://nodejs.org/api/path.html#path_path_join_paths\"><code>path.join</code></a> API joins multiple path segments together, creating a combined path string that works across all platforms.</li>\n</ul>\n<p>我们使用一个相对当前正在执行JavaScript文件的路径，这样您的相对路径将在开发模式和打包模式中都将有效。</p>\n<h3>额外：将功能添加到您的网页内容</h3>\n<p>此刻，您可能想知道如何为您的应用程序添加更多功能。</p>\n<p>对于与您的网页内容的任何交互，您想要将脚本添加到您的渲染器进程中。 由于渲染器运行在正常的 Web 环境中，因此您可以在 <code>index.html</code> 文件关闭 <code>&lt;/body&gt;</code> 标签之前添加一个 <code>&lt;script&gt;</code> 标签，来包括您想要的任意脚本：</p>\n<pre><code class=\"language-html\">&lt;script src=&quot;./renderer.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>The code contained in <code>renderer.js</code> can then use the same JavaScript APIs and tooling you use for typical front-end development, such as using <a href=\"https://webpack.js.org\"><code>webpack</code></a> to bundle and minify your code or <a href=\"https://reactjs.org\">React</a> to manage your user interfaces.</p>\n<h3>回顾</h3>\n<p>完成上述步骤后，您应该有一个功能齐全的Electron程序，如下所示：</p>\n<p><img src=\"https://yinyuejun.top/public/simplest-electron-app.png\" alt=\"最简的 Electron 应用程序\"></p>\n<!--TODO(erickzhao): Remove the individual code blocks for static website -->\n<p>完整代码如下：</p>\n<pre><code class=\"language-js\">// main.js\n\n// Modules to control application life and create native browser window\nconst { app, BrowserWindow } = require('electron')\nconst path = require('path')\n\nfunction createWindow () {\n  // Create the browser window.\n  const mainWindow = new BrowserWindow({\n    width: 800,\n    height: 600,\n    webPreferences: {\n      preload: path.join(__dirname, 'preload.js')\n    }\n  })\n\n  // and load the index.html of the app.\n  mainWindow.loadFile('index.html')\n\n  // Open the DevTools.\n  // mainWindow.webContents.openDevTools()\n}\n\n// This method will be called when Electron has finished\n// initialization and is ready to create browser windows.\n// 部分 API 在 ready 事件触发后才能使用。\napp.whenReady().then(() =&gt; {\n  createWindow()\n\n  app.on('activate', function () {\n    // On macOS it's common to re-create a window in the app when the\n    // dock icon is clicked and there are no other windows open.\n    if (BrowserWindow.getAllWindows().length === 0) createWindow()\n  })\n})\n\n// Quit when all windows are closed, except on macOS. There, it's common\n// for applications and their menu bar to stay active until the user quits\n// explicitly with Cmd + Q.\napp.on('window-all-closed', function () {\n  if (process.platform !== 'darwin') app.quit()\n})\n\n// In this file you can include the rest of your app's specific main process\n// code. 也可以拆分成几个文件，然后用 require 导入。\n</code></pre>\n<pre><code class=\"language-js\">// preload.js\n\n// All of the Node.js APIs are available in the preload process.\n// 它拥有与Chrome扩展一样的沙盒。\nwindow.addEventListener('DOMContentLoaded', () =&gt; {\n  const replaceText = (selector, text) =&gt; {\n    const element = document.getElementById(selector)\n    if (element) element.innerText = text\n  }\n\n  for (const dependency of ['chrome', 'node', 'electron']) {\n    replaceText(`${dependency}-version`, process.versions[dependency])\n  }\n})\n</code></pre>\n<pre><code class=\"language-html\">&lt;!--index.html--&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&gt;\n    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; script-src 'self'&quot;&gt;\n    &lt;meta http-equiv=&quot;X-Content-Security-Policy&quot; content=&quot;default-src 'self'; script-src 'self'&quot;&gt;\n    &lt;title&gt;Hello World!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello World!&lt;/h1&gt;\n    We are using Node.js &lt;span id=&quot;node-version&quot;&gt;&lt;/span&gt;,\n    Chromium &lt;span id=&quot;chrome-version&quot;&gt;&lt;/span&gt;,\n    and Electron &lt;span id=&quot;electron-version&quot;&gt;&lt;/span&gt;.\n\n    &lt;!-- You can also require other files to run in this process --&gt;\n    &lt;script src=&quot;./renderer.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<pre><code class=\"language-fiddle\"></code></pre>\n<p>总结我们所做的所有步骤：</p>\n<p>*我们启动了一个Node.js程序，并将Electron添加为依赖。</p>\n<ul>\n<li>\n<p>We created a <code>main.js</code> script that runs our main process, which controls our app<br>\nand runs in a Node.js environment. 在此脚本中， 我们使用 Electron 的 <code>app</code> 和  <code>BrowserWindow</code> 模块来创建一个浏览器窗口，在一个单独的进程(渲染器)中显示网页内容。</p>\n</li>\n<li>\n<p>为了访问渲染器中的Node.js的某些功能，我们在 <code>BrowserWindow</code> 的构造函数上附加了一个预加载脚本。</p>\n</li>\n</ul>\n<h2>打包并分发您的应用程序</h2>\n<p>最快捷的打包方式是使用 <a href=\"https://www.electronforge.io\">Electron Forge</a>。</p>\n<ol>\n<li>\n<p>将 Electron Forge 添加到您应用的开发依赖中，并使用其&quot;import&quot;命令设置 Forge 的脚手架：</p>\n<pre><code class=\"language-sh\">npm install --save-dev @electron-forge/cli\nnpx electron-forge import\n\n✔ Checking your system\n✔ Initializing Git Repository\n✔ Writing modified package.json file\n✔ Installing dependencies\n✔ Writing modified package.json file\n✔ Fixing .gitignore\n\nWe have ATTEMPTED to convert your app to be in a format that electron-forge understands.\n\nThanks for using &quot;electron-forge&quot;!!!\n</code></pre>\n</li>\n<li>\n<p>使用 Forge 的 <code>make</code> 命令来创建可分发的应用程序：</p>\n<pre><code class=\"language-sh\">npm run make\n\n&gt; my-electron-app@1.0.0 make /my-electron-app\n&gt; electron-forge make\n\n✔ Checking your system\n✔ Resolving Forge Config\nWe need to package your application before we can make it\n✔ Preparing to Package Application for arch: x64\n✔ Preparing native dependencies\n✔ Packaging Application\nMaking for the following targets: zip\n✔ Making for target: zip - On platform: darwin - For arch: x64\n</code></pre>\n<p>Electron Forge creates the <code>out</code> folder where your package will be located:</p>\n<pre><code class=\"language-plain\">// Example for macOS\nout/\n├── out/make/zip/darwin/x64/my-electron-app-darwin-x64-1.0.0.zip\n├── ...\n└── out/my-electron-app-darwin-x64/my-electron-app.app/Contents/MacOS/my-electron-app\n</code></pre>\n</li>\n</ol>\n<!-- [advanced-installation]: ./installation.md -->\n<!-- [app]: ../api/app.md\n[browser-window]: ../api/browser-window.md -->\n<!-- [app-ready]: ../api/app.md#event-ready\n[app-when-ready]: ../api/app.md#appwhenready -->\n<!-- [window-all-closed]: ../api/app.md#event-window-all-closed\n[app-quit]: ../api/app.md#appquit\n\n[activate]: ../api/app.md#event-activate-macos\n\n[Process Model]: ./process-model.md -->\n",
            "url": "https://yinyuejun.top/posts/electron.html",
            "title": "快速入门",
            "summary": "快速入门",
            "date_modified": "2023-07-21T00:00:00.000Z",
            "author": {
                "name": "你的饮月君",
                "url": "https://yinyuejun.top"
            }
        },
        {
            "content_html": "<h1>下班倒计时</h1>\n<pre><code class=\"language-javascript\">// ==UserScript==\n// @name         下班倒计时\n// @namespace    https://bbs.tampermonkey.net.cn/\n// @version      0.1.1\n// @description  一个提醒你准时下班的demo,请使用ScriptCat运行\n// @author       yinyuejun\n// @crontab      59 17 * * 1,2,3,4,5\n// @grant        GM_notification\n// @grant        GM_getValue\n// @grant        GM_setValue\n// @grant        GM_updateNotification\n// @debug\n// ==/UserScript==\nfunction getAvatarAndImage(id) {\n  const baseUrl = &quot;https://gitee.com/hewang1an/StarRail-plugin/raw/main/resources/panel/resources&quot;;\n  return {\n    avatarUrl: baseUrl + `/avatar/${id}.png`,\n    charImageUrl: baseUrl + `/char_image/${id}.png`,\n  };\n}\n\nasync function fetchCharacterData() {\n  try {\n    const response = await fetch(&quot;https://songzhanpeng.github.io/character.json&quot;);\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error(&quot;Error fetching character data:&quot;, error);\n    return null;\n  }\n}\n\nasync function getRandomRole() {\n  const cachedData = GM_getValue(&quot;characterData&quot;);\n  if (cachedData) {\n    const roleList = Object.entries(cachedData);\n    const randomIndex = Math.floor(Math.random() * roleList.length);\n    const roleInfo = roleList[randomIndex];\n    const { avatarUrl, charImageUrl } = getAvatarAndImage(roleInfo[0]);\n    return {\n      id: roleInfo[1].id,\n      name: roleInfo[1].name,\n      avatar: avatarUrl,\n      charImage: charImageUrl,\n    };\n  } else {\n    const characterData = await fetchCharacterData();\n    if (characterData) {\n      GM_setValue(&quot;characterData&quot;, characterData);\n      return getRandomRole();\n    }\n    return null;\n  }\n}\n\n(async () =&gt; {\n\n    const role = await getRandomRole();\n    let i;\n    GM_notification({\n        title: `${role.name}:下班60s倒计时`,\n        text: '准时下班，美好生活',\n        image: role.avatar,\n        ondone: (user) =&gt; {\n            console.log('done user:', user);\n            clearInterval(i);\n            resolve();\n        },\n        onclick: () =&gt; {\n            console.log('click');\n        },\n        oncreate: (id) =&gt; {\n            let t = 1;\n            i = setInterval(() =&gt; {\n                GM_updateNotification(id, {\n                    title: '下班' + (60 - t) + 's倒计时',\n                    progress: 100 / 60 * t\n                });\n                if (t == 60) {\n                    clearInterval(i);\n                    GM_updateNotification(id, {\n                        title: '下班啦！',\n                        progress: 100\n                    });\n                    resolve();\n                }\n                t++;\n            }, 1000);\n        },\n        // 开启进度条模式\n        progress: 0,\n    });\n})();\n\n\n\n</code></pre>\n",
            "url": "https://yinyuejun.top/posts/下班倒计时.html",
            "title": "下班倒计时",
            "summary": "下班倒计时",
            "date_modified": "2023-07-21T00:00:00.000Z",
            "author": {
                "name": "你的饮月君",
                "url": "https://yinyuejun.top"
            }
        },
        {
            "content_html": "<h1>定时提醒小助手</h1>\n<pre><code class=\"language-javascript\">// ==UserScript==\n// @name         提醒喝水小助手\n// @namespace    https://bbs.tampermonkey.net.cn/\n// @version      0.1.0\n// @description  工作日每半个小时提醒你喝水，定时时间可以自行修改\n// @author       yinyuejun\n// @crontab      */30 10-20/1 * * 1-5\n// @grant        GM_notification\n// @grant        GM_getValue\n// @grant        GM_setValue\n// @console log\n// ==/UserScript==\n\nfunction getAvatarAndImage(id) {\n  const baseUrl = &quot;https://gitee.com/hewang1an/StarRail-plugin/raw/main/resources/panel/resources&quot;;\n  return {\n    avatarUrl: baseUrl + `/avatar/${id}.png`,\n    charImageUrl: baseUrl + `/char_image/${id}.png`,\n  };\n}\n\nasync function fetchCharacterData() {\n  try {\n    const response = await fetch(&quot;https://songzhanpeng.github.io/character.json&quot;);\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error(&quot;Error fetching character data:&quot;, error);\n    return null;\n  }\n}\n\nasync function getRandomRole() {\n  const cachedData = GM_getValue(&quot;characterData&quot;);\n  if (cachedData) {\n    const roleList = Object.entries(cachedData);\n    const randomIndex = Math.floor(Math.random() * roleList.length);\n    const roleInfo = roleList[randomIndex];\n    const { avatarUrl, charImageUrl } = getAvatarAndImage(roleInfo[0]);\n    return {\n      id: roleInfo[1].id,\n      name: roleInfo[1].name,\n      avatar: avatarUrl,\n      charImage: charImageUrl,\n    };\n  } else {\n    const characterData = await fetchCharacterData();\n    if (characterData) {\n      GM_setValue(&quot;characterData&quot;, characterData);\n      return getRandomRole();\n    }\n    return null;\n  }\n}\n\n(async () =&gt; {\n  const currentDate = new Date();\n  const currentHour = currentDate.getHours();\n\n  if (currentHour &gt;= 9 &amp;&amp; currentHour &lt;= 20) {\n    const role = await getRandomRole();\n    if (role) {\n      GM_notification({\n        title: `${role.name}的温馨提醒`,\n        text: &quot;开拓者，是时候喝杯水休息一下了&quot;,\n        image: role.avatar,\n      });\n    }\n  }\n})();\n</code></pre>\n",
            "url": "https://yinyuejun.top/posts/定时提醒喝水小助手.html",
            "title": "定时提醒小助手",
            "summary": "定时提醒小助手",
            "date_modified": "2023-07-21T00:00:00.000Z",
            "author": {
                "name": "你的饮月君",
                "url": "https://yinyuejun.top"
            }
        },
        {
            "content_html": "<h1>提醒走动小助手</h1>\n<pre><code class=\"language-javascript\">// ==UserScript==\n// @name         提醒走动小助手\n// @namespace    https://bbs.tampermonkey.net.cn/\n// @version      0.1.0\n// @description  每隔一个小时提醒你走动一下，定时时间可以自行修改\n// @author       yinyuejun\n// @crontab      0 10-20/1 * * 1-5\n// @grant        GM_notification\n// @grant        GM_getValue\n// @grant        GM_setValue\n// @console log\n// ==/UserScript==\n\nfunction getAvatarAndImage(id) {\n  const baseUrl = &quot;https://gitee.com/hewang1an/StarRail-plugin/raw/main/resources/panel/resources&quot;;\n  return {\n    avatarUrl: baseUrl + `/avatar/${id}.png`,\n    charImageUrl: baseUrl + `/char_image/${id}.png`,\n  };\n}\n\nasync function fetchCharacterData() {\n  try {\n    const response = await fetch(&quot;https://songzhanpeng.github.io/character.json&quot;);\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error(&quot;Error fetching character data:&quot;, error);\n    return null;\n  }\n}\n\nasync function getRandomRole() {\n  const cachedData = GM_getValue(&quot;characterData&quot;);\n  if (cachedData) {\n    const roleList = Object.entries(cachedData);\n    const randomIndex = Math.floor(Math.random() * roleList.length);\n    const roleInfo = roleList[randomIndex];\n    const { avatarUrl, charImageUrl } = getAvatarAndImage(roleInfo[0]);\n    return {\n      id: roleInfo[1].id,\n      name: roleInfo[1].name,\n      avatar: avatarUrl,\n      charImage: charImageUrl,\n    };\n  } else {\n    const characterData = await fetchCharacterData();\n    if (characterData) {\n      GM_setValue(&quot;characterData&quot;, characterData);\n      return getRandomRole();\n    }\n    return null;\n  }\n}\n\n(async () =&gt; {\n  const currentDate = new Date();\n  const currentHour = currentDate.getHours();\n\n  if (currentHour &gt;= 9 &amp;&amp; currentHour &lt;= 20) {\n    const role = await getRandomRole();\n    console.log(role)\n    GM_notification({\n      title: role.name,\n      text: &quot;你已经坐了一小时了，走动一下吧！&quot;,\n      image: role.avatar,\n    });\n  }\n})();\n\n</code></pre>\n",
            "url": "https://yinyuejun.top/posts/提醒走动小助手.html",
            "title": "提醒走动小助手",
            "summary": "提醒走动小助手",
            "date_modified": "2023-07-21T00:00:00.000Z",
            "author": {
                "name": "你的饮月君",
                "url": "https://yinyuejun.top"
            }
        }
    ]
}